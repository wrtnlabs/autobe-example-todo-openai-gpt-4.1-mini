import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthUserJoin } from "../../../providers/postauthUserJoin";
import { UserAuth } from "../../../decorators/UserAuth";
import { UserPayload } from "../../../decorators/payload/UserPayload";
import { postauthUserLogin } from "../../../providers/postauthUserLogin";
import { postauthUserRefresh } from "../../../providers/postauthUserRefresh";

import { ITodoListUser } from "../../../api/structures/ITodoListUser";

@Controller("/auth/user")
export class AuthUserController {
  /**
   * Registration operation for todo_list_user role to create new user accounts
   * and issue initial tokens.
   *
   * This endpoint allows new users to register by providing their credentials.
   * It interacts with the todo_list_user table, specifically verifying unique
   * email and securely storing hashed passwords. Upon successful registration,
   * it returns authorized tokens allowing further authenticated interactions.
   * This operation is public and requires no prior authentication. Security
   * measures ensure data privacy and integrity during user creation. This
   * operation pairs with login and token refresh for managing user sessions
   * securely.
   *
   * @param connection
   * @param body User creation payload including email and password hash.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @UserAuth()
    user: UserPayload,
    @TypedBody()
    body: ITodoListUser.ICreate,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postauthUserJoin({
        user,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Login operation for todo_list_user role issuing access tokens after
   * successful authentication.
   *
   * Allows existing users to authenticate with email and password. Returns
   * authorized tokens upon successful authentication. Validates credentials
   * against stored password hash in todo_list_user table. Accessible publicly
   * for unauthenticated users. Part of core authentication flow with join and
   * refresh. Security precautions included to safeguard credentials and limit
   * brute force attempts.
   *
   * @param connection
   * @param body User login credentials with email and password.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("login")
  public async login(
    @UserAuth()
    user: UserPayload,
    @TypedBody()
    body: ITodoListUser.ILogin,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postauthUserLogin({
        user,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Token refresh operation for todo_list_user role renewing access tokens.
   *
   * Allows an authenticated user with a valid refresh token to obtain new
   * access tokens. Validates refresh token against stored sessions tied to
   * todo_list_user. Not accessible publicly; requires valid refresh token.
   * Supports continuous authenticated access without re-login. Security
   * measures enforce token expiry and revocation. Paired with join and login
   * operations to complete authentication cycle.
   *
   * @param connection
   * @param body Refresh token payload.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @UserAuth()
    user: UserPayload,
    @TypedBody()
    body: ITodoListUser.IRefresh,
  ): Promise<ITodoListUser.IAuthorized> {
    try {
      return await postauthUserRefresh({
        user,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
