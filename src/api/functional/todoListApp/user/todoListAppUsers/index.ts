import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ITodoListAppTodoListAppUsers } from "../../../../structures/ITodoListAppTodoListAppUsers";
import { IPageITodoListAppTodoListAppUsers } from "../../../../structures/IPageITodoListAppTodoListAppUsers";
export * as todoListAppTodoItems from "./todoListAppTodoItems/index";

/**
 * Retrieve detailed information of a specific todo list app user account.
 *
 * This operation fetches detailed information about a single user account
 * identified by their unique UUID. It retrieves the user's email, email
 * verification status, and timestamps related to when the account was created,
 * last updated, and deleted (if soft deleted).
 *
 * Security considerations require that only authorized roles can access this
 * endpoint since it exposes sensitive authentication data. The password hash
 * field is excluded to prevent exposure of sensitive information.
 *
 * The operation tightly couples with the todo_list_app_users table in the
 * Prisma schema ensuring that the exact fields and data integrity rules are
 * respected. It returns a complete user object matching the schema properties,
 * excluding sensitive password data.
 *
 * Typical errors include attempting to fetch a user ID that does not exist,
 * which should return a not-found error. Unauthorized access attempts should be
 * rejected with a 403 or similar error.
 *
 * This operation is distinct from list or update operations and serves as a
 * granular user data retrieval endpoint, often supporting administrative or
 * account management UI features.
 *
 * @param props.connection
 * @param props.id Unique identifier of the todo list app user
 * @path /todoListApp/user/todoListAppUsers/:id
 * @accessor api.functional.todoListApp.user.todoListAppUsers.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the todo list app user */
    id: string & tags.Format<"uuid">;
  };
  export type Response = ITodoListAppTodoListAppUsers.ISafe;

  export const METADATA = {
    method: "GET",
    path: "/todoListApp/user/todoListAppUsers/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoListApp/user/todoListAppUsers/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ITodoListAppTodoListAppUsers.ISafe =>
    typia.random<ITodoListAppTodoListAppUsers.ISafe>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update details of a specific todo list app user account.
 *
 * Update detailed information of an existing todo list app user account. The
 * request body must contain the updated email, password hash, email
 * verification status, and timestamps as needed. The user account is identified
 * by the id path parameter. Ownership and permission checks ensure only
 * authorized modification.
 *
 * This operation modifies core user identity fields and is critical for account
 * management and security enforcement.
 *
 * Proper validation and transactional integrity are essential to maintain data
 * consistency and application security.
 *
 * @param props.connection
 * @param props.id Unique identifier of the todo list app user to update
 * @param props.body Updated user account information for the specified user ID
 * @path /todoListApp/user/todoListAppUsers/:id
 * @accessor api.functional.todoListApp.user.todoListAppUsers.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the todo list app user to update */
    id: string & tags.Format<"uuid">;

    /** Updated user account information for the specified user ID */
    body: ITodoListAppTodoListAppUsers.IUpdate;
  };
  export type Body = ITodoListAppTodoListAppUsers.IUpdate;
  export type Response = ITodoListAppTodoListAppUsers;

  export const METADATA = {
    method: "PUT",
    path: "/todoListApp/user/todoListAppUsers/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/todoListApp/user/todoListAppUsers/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): ITodoListAppTodoListAppUsers =>
    typia.random<ITodoListAppTodoListAppUsers>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a todoListApp user account by id.
 *
 * Permanently removes the user account record specified by the {id} in the path
 * from the database, including cascade deletion of owned todo items as per
 * Prisma schema rules. This operation MUST verify that the requesting user is
 * authorized to delete their own account to prevent unauthorized user removal.
 * It operates directly on the todo_list_app_users table, which stores user
 * authentication credentials and related metadata.
 *
 * Security considerations require strong authentication and authorization
 * checks, as deleting a user account cannot be undone and will remove all
 * associated task data. This endpoint is critical and must ensure only the
 * authenticated owner can perform this deletion.
 *
 * Expected behavior includes validation of the {id} as a UUID, verification of
 * user ownership, and a hard (permanent) delete operation with no recovery.
 *
 * No request body is sent, and no response body is returned on successful
 * deletion. Error handling includes responding with authorization errors for
 * unauthorized attempts, not found errors if the user does not exist, and
 * appropriate server error messages for unexpected failures.
 *
 * @param props.connection
 * @param props.id Unique identifier of the user account to delete
 * @path /todoListApp/user/todoListAppUsers/:id
 * @accessor api.functional.todoListApp.user.todoListAppUsers.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the user account to delete */
    id: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/todoListApp/user/todoListAppUsers/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/todoListApp/user/todoListAppUsers/${encodeURIComponent(props.id ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("id")(() => typia.assert(props.id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a filtered, paginated list of todo list app users.
 *
 * This operation enables clients to perform complex search and retrieval
 * operations over todo list app users. The request body supports specifying
 * search filters like email substring matching, filtering by email verification
 * status, and sorting preferences including sort column and order.
 *
 * The response is a paginated list of user summary objects optimized for UI
 * rendering in admin or management dashboards.
 *
 * Proper validation of input parameters in the request body ensures effective
 * filtering and prevents injection or invalid queries.
 *
 * Security constraints mean only authorized user roles can execute this
 * operation, limiting exposure of sensitive user data.
 *
 * This endpoint complements single-entity retrieval and update endpoints
 * providing complete user account management capabilities.
 *
 * @param props.connection
 * @param props.body Search criteria and pagination parameters for todo list
 *   user filtering
 * @path /todoListApp/user/todoListAppUsers
 * @accessor api.functional.todoListApp.user.todoListAppUsers.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search criteria and pagination parameters for todo list user
     * filtering
     */
    body: ITodoListAppTodoListAppUsers.IRequest;
  };
  export type Body = ITodoListAppTodoListAppUsers.IRequest;
  export type Response = IPageITodoListAppTodoListAppUsers.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/todoListApp/user/todoListAppUsers",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/todoListApp/user/todoListAppUsers";
  export const random = (): IPageITodoListAppTodoListAppUsers.ISummary =>
    typia.random<IPageITodoListAppTodoListAppUsers.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
