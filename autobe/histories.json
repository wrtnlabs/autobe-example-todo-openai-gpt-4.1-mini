[{"id":"01999b2c-f3b4-74e9-bc8d-01057d16a3aa","type":"userMessage","contents":[{"type":"text","text":"I want to create a Todo list application.\r\n\r\nWhen I build an application, I only want the minimum functionality required for Todo list.\r\n\r\nSince I'm not familiar with programming, please write a requirements analysis report as you see fit."}],"created_at":"2025-09-30T15:10:38.516Z"},{"id":"01999b2c-f6d6-7729-b40d-2cee88b2e41b","type":"assistantMessage","text":"Thank you for sharing your desire to create a Todo list application with the minimum necessary functionality. To write a clear and useful requirements analysis report, I want to gather a bit more information to ensure the report aligns with your expectations.\n\nHere are a few simple questions to help me understand your needs better:\n\n1. Who will use this Todo list app? Just you, or multiple users?\n2. What basic actions do you want to do with Todo items? For example: add a new task, mark a task as done, delete a task, or edit a task?\n3. Do you want to organize tasks in any way, such as by categories or due dates?\n4. Is there any specific device or platform you want to use this app on? (e.g., mobile phone, web browser)\n5. Do you want to keep the data private to one device, or accessible from anywhere (cloud)?\n6. Any other features you consider absolutely necessary for the app?\n\nFeel free to answer any or all of these, and I can draft the requirements analysis based on your input. If you want, you can also say \"Please proceed as you see fit,\" and I can create a minimal requirements plan for you.","created_at":"2025-09-30T15:10:39.318Z","completed_at":"2025-09-30T15:10:43.682Z"},{"id":"01999b2d-07f2-74af-835c-c2c3607541d5","type":"userMessage","contents":[{"type":"text","text":"I'm not familiar with the analyze feature. Please determine everything by yourself, and just show me the analysis report."}],"created_at":"2025-09-30T15:10:43.698Z"},{"type":"analyze","id":"01999b30-3e1c-766f-a5e4-646fdc798462","instruction":"Focus on minimal Todo list application with essential features only. Users should be able to add tasks, mark tasks as done, and delete tasks. There will be a single user role (no multi-user support). Tasks do not need categorization or complex organization. The app should store data locally or simply. The platform is unspecified, so design generic minimal functional requirements for a basic Todo list app with core CRUD operations on tasks.","prefix":"todoListApp","roles":[{"name":"user","description":"Authenticated users who can create, read, update, and delete their own todo items. They have personal access to their tasks and can manage them fully.","kind":"member"}],"files":[{"reason":"To provide the table of contents for the entire project documentation, outlining the structure and files.","filename":"00-toc.md","documentType":"service-overview","outline":["Service Overview","User Roles and Authentication","Functional Requirements","Error Handling and Performance","Developer Note"],"audience":"backend developers","content":"# Todo List Application - Functional Requirements Analysis\n\n## 1. Introduction\nThis specification defines the complete set of functional requirements for the todoListApp backend. The system supports a single user role: \"user,\" where each user can create, view, update, and delete their own todo items exclusively. The requirements employ the Easy Approach to Requirements Syntax (EARS) for clarity and testability, making all system behaviors explicit and verifiable.\n\nThe overall goal is to provide a minimal but fully functional todo list application backend that ensures secure and reliable management of personal task items.\n\n## 2. Todo Item Lifecycle\n\n### 2.1 Create Todo Item\nWHEN a user submits a request to create a new todo item with a description, THE system SHALL validate the description according to the validation rules in section 4 and create a todo item associated exclusively with that user. The created todo item SHALL have a unique identifier and its status SHALL be set to \"pending\" initially.\n\n### 2.2 Retrieve Todo List\nWHEN a user requests to view their todo list, THE system SHALL return all todo items owned by that user ordered by their creation timestamp in ascending order.\n\n### 2.3 Update Todo Item\nWHEN a user requests to mark a todo item as done, THE system SHALL verify ownership of the item and update its status to \"done\".\n\nWHEN a user requests to edit a todo item's description, THE system SHALL verify that the item is owned by the user and is currently in the \"pending\" status before updating the description.\n\n### 2.4 Delete Todo Item\nWHEN a user requests deletion of a todo item, THE system SHALL verify ownership and delete the item.\n\n## 3. User Actions\n\n- Add a new todo item by providing a description.\n- Retrieve the full list of their todo items.\n- Mark a specific todo item as done.\n- Edit the description of a todo item currently in \"pending\" status.\n- Delete a todo item.\n\n## 4. Business Rules\n\n- Task descriptions SHALL be non-empty strings with a maximum length of 256 characters.\n- All todo items SHALL be associated with a single user who is the only one with access rights.\n- Status of todo items SHALL only be \"pending\" or \"done\".\n- Unique identifiers for todo items SHALL be unique per user and immutable.\n- Users SHALL NOT be able to view, modify, or delete todo items belonging to other users.\n\n## 5. Performance Expectations\n\n- THE system SHALL respond to todo item creation, retrieval, update, and deletion requests within 2 seconds under normal load conditions.\n- THE retrieval of up to 100 todo items SHALL complete within 1 second.\n\n## 6. Error Handling\n\n- IF a todo item creation or update request contains an invalid description (empty or exceeding 256 characters), THEN THE system SHALL reject the request and respond with a descriptive validation error message.\n- IF a user attempts to view or modify a todo item they do not own, THEN THE system SHALL reject the request with an authorization error.\n- IF a requested todo item does not exist (e.g., invalid ID), THEN THE system SHALL respond with a not-found error message.\n- IF an unexpected system error occurs, THEN THE system SHALL respond with a generic error message while logging the details internally.\n\n## 7. Diagrams\n\n```mermaid\ngraph LR\n  A[\"Start\"] --> B[\"User Requests Create Todo Item\"]\n  B --> C[\"Validate Description\"]\n  C --> D{\"Description Valid?\"}\n  D -->|\"Yes\"| E[\"Create Todo Item with Status 'pending'\"]\n  D -->|\"No\"| F[\"Return Validation Error\"]\n  E --> G[\"User Views Todo List\"]\n  G --> H[\"Retrieve User's Todo Items\"]\n  H --> I[\"Return Todo List\"]\n\n  G --> J[\"User Requests Mark Item as Done\"]\n  J --> K[\"Verify Ownership\"]\n  K --> L{\"Ownership Valid?\"}\n  L -->|\"Yes\"| M[\"Update Status to 'done'\"]\n  L -->|\"No\"| N[\"Return Authorization Error\"]\n\n  G --> O[\"User Requests Edit Item Description\"]\n  O --> P[\"Verify Ownership\"]\n  P --> Q{\"Ownership Valid?\"}\n  Q -->|\"Yes\"| R[\"Check Item Status 'pending'? \"]\n  Q -->|\"No\"| N\n  R -->|\"Yes\"| S[\"Update Description\"]\n  R -->|\"No\"| N\n\n  G --> T[\"User Requests Delete Item\"]\n  T --> U[\"Verify Ownership\"]\n  U --> V{\"Ownership Valid?\"}\n  V -->|\"Yes\"| W[\"Delete Todo Item\"]\n  V -->|\"No\"| N\n\n  M --> G\n  S --> G\n  W --> G\n  F --> B\n  N --> G\n  I --> \"End\"\n```\n\n---\n\nThe requirements are crafted exclusively as business rules using natural language and the EARS format, focusing on expected behaviors and constraints. The technical implementation details such as API protocols, database models, or internal system design are left to the development team to decide."},{"reason":"To describe high-level service overview and business model for the Todo list application, clarifying purpose and value.","filename":"01-service-overview.md","documentType":"service-overview","outline":["Introduction and Background","Business Model","Core Features","Success Metrics"],"audience":"backend developers","content":"# Todo List Application - Functional Requirements Analysis\n\n## 1. Introduction\nThis document defines the business functional requirements for the todoListApp backend. The application supports a minimal todo list feature set allowing authenticated users to create, retrieve, update, and delete their own todo items. The system supports a single user role: \"user\", who has exclusive access to their own todo items. This document uses the EARS format for clarity and testability.\n\n## 2. Todo Item Lifecycle\n\n### 2.1 Create Todo Item\nWHEN a user submits a request to create a new todo item with a description, THE system SHALL validate the description to be a non-empty string with a maximum length of 256 characters, THEN create a todo item with a unique identifier and initial status \"pending\" associated exclusively with the creating user.\n\n### 2.2 Retrieve Todo List\nWHEN a user requests to view their todo list, THE system SHALL return all todo items owned by that user ordered by creation timestamp ascending.\n\n### 2.3 Update Todo Item\nWHEN a user requests to mark a todo item as done, THE system SHALL verify ownership of the item by the requesting user, THEN update its status to \"done\".\n\nWHEN a user requests to edit the description of a todo item, THE system SHALL verify that the item is in \"pending\" state and owned by the requesting user, THEN update the description to a new valid non-empty string with a maximum length of 256 characters.\n\n### 2.4 Delete Todo Item\nWHEN a user requests deletion of a todo item, THE system SHALL verify ownership of the item by the requesting user, THEN remove the todo item from the system.\n\n## 3. User Actions\n- Add a new todo item with a description.\n- Retrieve the user's complete todo list.\n- Mark a todo item as done.\n- Edit a pending todo item's description.\n- Delete a todo item.\n\n## 4. Business Rules\n- Users SHALL only access and modify their own todo items.\n- Todo item descriptions SHALL be validated for length (max 256 characters) and non-empty status.\n- Todo item status SHALL only have values \"pending\" or \"done\".\n- Todo item identifiers SHALL be unique per user.\n\n## 5. Performance Expectations\n- THE system SHALL respond to create, update, delete, and retrieval requests within 2 seconds under normal operating conditions.\n- THE system SHALL retrieve up to 100 todo items within 1 second.\n\n## 6. Error Handling\n- IF a todo item creation request includes an invalid description (empty or exceeding length), THEN THE system SHALL respond with a clear error message indicating invalid input and reject the creation.\n- IF a user attempts to operate on a todo item they do not own or that does not exist, THEN THE system SHALL respond with an authorization or not found error as appropriate.\n- IF an unexpected system error occurs, THEN THE system SHALL return a generic failure error message.\n\n## 7. Diagrams\n\n```mermaid\ngraph LR\n  A[\"Start\"] --> B[\"User Requests Create Todo Item\"]\n  B --> C[\"Validate Description\"]\n  C --> D{\"Is Description Valid?\"}\n  D -->|\"Yes\"| E[\"Create Todo Item with Status Pending\"]\n  D -->|\"No\"| F[\"Return Invalid Description Error\"]\n  E --> G[\"User Views Todo List\"]\n  G --> H[\"Retrieve User's Todo Items\"]\n  H --> I[\"Return Todo List\"]\n\n  G --> J[\"User Requests Mark Item Done\"]\n  J --> K[\"Verify Ownership\"]\n  K --> L{\"Ownership Valid?\"}\n  L -->|\"Yes\"| M[\"Update Status to Done\"]\n  L -->|\"No\"| N[\"Return Authorization Error\"]\n\n  G --> O[\"User Requests Delete Item\"]\n  O --> P[\"Verify Ownership\"]\n  P --> Q{\"Ownership Valid?\"}\n  Q -->|\"Yes\"| R[\"Delete Todo Item\"]\n  Q -->|\"No\"| N\n\n  M --> G\n  R --> G\n  F --> B\n  N --> G\n  I --> \"End\"\n```\n\n"},{"reason":"To define user roles, authentication flow, and permission structures necessary for the Todo list application.","filename":"02-user-roles.md","documentType":"requirement","outline":["User Role Definitions","Authentication Flow Requirements","Permission Matrix"],"audience":"backend developers","content":"# User Roles and Authentication for Todo list application\n\n## 1. Introduction\nThis document provides the complete business requirements for user roles, authentication flows, and permissions for the Todo list application backend. It focuses on minimal functional scope for a simple Todo list app where a single type of authenticated user can manage their own tasks.\n\nThis document provides business requirements only. All technical implementation decisions including architecture, APIs, and database design are at the discretion of the development team. The document prescribes WHAT the system must do, not HOW it shall be built.\n\n## 2. User Role Definitions\n\n### 2.1 User Roles Overview\nThere is only one user role in this system:\n\n| Role Name | Description |\n|-----------|-------------|\n| user      | Authenticated users who can create, read, update, and delete their own todo items. They have personal access and full management rights over their tasks. |\n\n### 2.2 Role Characteristics\n- Users are individuals who register and authenticate with the system.\n- Each user can only access and manage their own todo items.\n- There are no administrative or multi-user roles currently.\n\n## 3. Authentication Flow Requirements\n\n### 3.1 Core Authentication Functions\n- THE todoListApp SHALL allow users to register an account with an email address and password.\n- WHEN a user submits registration data, THE todoListApp SHALL validate the email format and password strength.\n- THE todoListApp SHALL allow users to log in using email and password credentials.\n- WHEN a user submits login credentials, THE todoListApp SHALL verify them and establish a secure user session.\n- THE todoListApp SHALL provide a logout function that invalidates the user session.\n- WHEN a user requests password reset, THE todoListApp SHALL provide a mechanism to securely reset the password via email.\n- THE todoListApp SHALL maintain authenticated user sessions securely until logout or session expiration.\n- THE todoListApp SHALL enforce a session expiration time of 30 minutes of inactivity.\n- THE todoListApp SHALL require users to verify their email addresses before gaining full access.\n- WHEN a user attempts to access any Todo item data, THE todoListApp SHALL verify the user is authenticated.\n\n### 3.2 Registration\n- WHEN a new user registers, THE todoListApp SHALL ensure the email is unique in the system.\n- IF the email is already registered, THEN THE todoListApp SHALL reject registration with an appropriate error message.\n\n### 3.3 Password Rules\n- THE todoListApp SHALL require passwords to be at least 8 characters long.\n- THE todoListApp SHALL enforce password complexity rules (at least one uppercase letter, one number, and one special character).\n\n### 3.4 Email Verification\n- THE todoListApp SHALL send a verification email upon registration.\n- WHEN the user clicks the verification link, THE todoListApp SHALL mark the email as verified.\n- IF the user has not verified their email within 24 hours, THEN THE todoListApp SHALL restrict access to todo item management features.\n\n### 3.5 Error Handling\n- IF login credentials are invalid, THEN THE todoListApp SHALL return an authentication failure error.\n- IF the user attempts actions without authentication, THEN THE todoListApp SHALL reject with appropriate authorization error.\n\n## 4. Permission Matrix\n\n| Action               | user (Authenticated) |\n|----------------------|---------------------|\n| Register             | ✅                  |\n| Login                | ✅                  |\n| Logout               | ✅                  |\n| Create Todo Item     | ✅                  |\n| Read Own Todo Items  | ✅                  |\n| Update Own Todo Item | ✅                  |\n| Delete Own Todo Item | ✅                  |\n| Access Others' Items | ❌                  |\n| Manage Other Users   | ❌                  |\n\n### 4.1 Access Control Rules\n- Users SHALL only be able to access todo items they own.\n- Any attempt to access or modify todo items belonging to another user SHALL be rejected.\n\n## 5. Summary\nThis document specifies a single user role \"user\" who can fully manage their own todo items. It details all authentication flows including registration, login, logout, email verification, and session management with explicit rules on password complexity and error handling.\nThe permission matrix clearly defines capabilities limited to the user's own data.\n\nMermaid Diagram illustrating Authentication Flow:\n\n```mermaid\ngraph LR\n  A[\"User Registration\"] --> B[\"Validate Email and Password\"]\n  B --> C{\"Email Unique?\"}\n  C -->|\"Yes\"| D[\"Create User Account\"]\n  C -->|\"No\"| E[\"Reject Registration\"]\n  D --> F[\"Send Verification Email\"]\n  F --> G[\"User Verifies Email\"]\n  G --> H[\"Activate User Account\"]\n  \n  subgraph \"Login Process\"\n    I[\"User Login\"] --> J[\"Validate Credentials\"]\n    J --> K{\"Credentials Valid?\"}\n    K -->|\"Yes\"| L[\"Create Session\"]\n    K -->|\"No\"| M[\"Return Error\"]\n  end\n\n  L --> N[\"Access Todo Items\"]\n  M --> I\n  E --> A\n```\n\nThis document covers only business requirements for user roles and authentication in natural language and EARS format. All technical realizations including API design, database schemas, and security implementations are left to developers' discretion."},{"reason":"To describe detailed functional requirements including todo item management, business rules, and user actions for the Todo list application.","filename":"03-functional-requirements.md","documentType":"requirement","outline":["Todo Item Lifecycle","User Actions","Business Rules","Performance Expectations","Error Handling"],"audience":"backend developers","content":"# Todo List Application - Functional Requirements Analysis\n\n## 1. Introduction\nThis document defines the business functional requirements for the todoListApp backend. The application supports a minimal todo list feature set allowing authenticated users to manage their own list of todo items through creation, retrieval, update, and deletion operations.\n\nThe system supports a single user role: \"user\". Each user has exclusive access to their own todo items. This document uses the EARS format for clarity and testability.\n\n## 2. Todo Item Lifecycle\n\n### 2.1 Create Todo Item\nWHEN a user submits a request to create a new todo item with a description, THE system SHALL validate the description and create a todo item with a unique identifier and status \"pending\".\n\nBusiness rules:\n- The description SHALL be a non-empty string with a maximum length of 256 characters.\n- The created todo item SHALL be associated exclusively with the creating user.\n- The todo item status SHALL initially be \"pending\".\n\n### 2.2 Retrieve Todo List\nWHEN a user requests to view their todo list, THE system SHALL return all todo items owned by that user ordered by creation timestamp ascending.\n\n### 2.3 Update Todo Item\nWHEN a user requests to mark a todo item as done, THE system SHALL verify ownership and update its status to \"done\".\n\nWHEN a user requests to edit the description of a todo item, THE system SHALL verify that the item is in \"pending\" state and owned by the user, then update the description.\n\n### 2.4 Delete Todo Item\nWHEN a user requests deletion of a todo item, THE system SHALL verify ownership and remove the todo item.\n\n## 3. User Actions\n- Add a new todo item with a description.\n- Retrieve the user's complete todo list.\n- Mark a todo item as done.\n- Edit a pending todo item's description.\n- Delete a todo item.\n\n## 4. Business Rules\n- Users SHALL only access and modify their own todo items.\n- Todo item descriptions SHALL be validated for length and non-empty status.\n- Todo item status field SHALL only have values \"pending\" or \"done\".\n- IDs of todo items SHALL be unique per user.\n\n## 5. Performance Expectations\n- THE system SHALL respond to create, update, delete, and retrieval requests within 2 seconds (under typical load).\n- Retrieval of up to 100 todo items SHALL complete within 1 second.\n\n## 6. Error Handling\n- IF a todo item creation request includes an invalid (empty or overly long) description, THEN THE system SHALL respond with an error indicating invalid input.\n- IF a user attempts operations on todo items they do not own or that do not exist, THEN THE system SHALL respond with proper authorization error.\n- IF unexpected system errors occur, THEN THE system SHALL return a generic failure message.\n\n## 7. Diagrams\n\n```mermaid\ngraph LR\n  A[\"Start\"] --> B[\"User Requests Create Todo Item\"]\n  B --> C[\"Validate Description\"]\n  C --> D{\"Is Description Valid?\"}\n  D -->|\"Yes\"| E[\"Create Todo Item with Status Pending\"]\n  D -->|\"No\"| F[\"Return Invalid Description Error\"]\n  E --> G[\"User Views Todo List\"]\n  G --> H[\"Retrieve User's Todo Items\"]\n  H --> I[\"Return Todo List\"]\n\n  G --> J[\"User Requests Mark Item Done\"]\n  J --> K[\"Verify Ownership\"]\n  K --> L{\"Ownership Valid?\"}\n  L -->|\"Yes\"| M[\"Update Status to Done\"]\n  L -->|\"No\"| N[\"Return Authorization Error\"]\n\n  G --> O[\"User Requests Delete Item\"]\n  O --> P[\"Verify Ownership\"]\n  P --> Q{\"Ownership Valid?\"}\n  Q -->|\"Yes\"| R[\"Delete Todo Item\"]\n  Q -->|\"No\"| N\n\n  M --> G\n  R --> G\n  F --> B\n  N --> G\n  I --> \"End\"\n```\n\n---\n\nThis document provides business requirements only. All technical implementation decisions, including architecture, APIs, database design, and other technical details, are at the discretion of the development team. The document describes what the system must do, not how it should be implemented."}],"created_at":"2025-09-30T15:10:45.693Z","completed_at":"2025-09-30T15:14:14.172Z","step":0},{"id":"01999b30-3e55-7088-aa28-36d33aa86fb4","type":"userMessage","contents":[{"type":"text","text":"Design the database schema."}],"created_at":"2025-09-30T15:14:14.229Z"},{"type":"prisma","id":"01999b31-7c0e-737c-8af0-e6a6b6f8283b","instruction":"Design a minimal database schema for a Todo list application with the following requirements: single user, basic task management with ability to add tasks, mark tasks as done, and delete tasks. Each task should have attributes for unique identifier, description, completion status, and timestamp fields (created and optionally updated). No need for complex relationships or categorization.","schemas":{"schema-01-actors.prisma":"/// User accounts for the Todo List Application, storing authentication data\n/// including email, password hash, email verification status, and\n/// timestamps. This entity represents individual users who own todo items.\n/// The table supports soft deletion for account recovery and provides audit\n/// fields for tracking creation and modification times. Email is unique\n/// allowing identification and login. Relates to todo_list_app_todo_items\n/// for ownership of tasks.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_app_users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// User's unique email address used for login and identity verification.\n  email String\n  \n  /// Hashed password for user authentication, never store plain text passwords.\n  password_hash String\n  \n  /// Flag indicating whether the user's email address has been verified.\n  email_verified Boolean\n  \n  /// Timestamp when the user account was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the user account was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  /// Timestamp indicating when the user account was soft deleted, if\n  /// applicable.\n  deleted_at DateTime? @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  todo_list_app_todo_items todo_list_app_todo_items[]\n  \n  @@unique([email])\n  @@index([created_at])\n}","schema-02-todo.prisma":"/// Represents individual todo items created and managed by users in the todo\n/// list application. Each item is tied exclusively to one user, with a\n/// status indicating completion state and timestamps for creation and last\n/// update. This model enables users to independently create, view, update,\n/// and delete their tasks while enforcing ownership and access control. It\n/// references the users table for ownership association.\n///\n/// @namespace Todo\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_app_todo_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n  \n  /// Owning user's {@link todo_list_app_users.id}.\n  todo_list_app_user_id String @db.Uuid\n  \n  /// Task description text. Non-empty string up to 256 characters, validated\n  /// by application logic.\n  description String\n  \n  /// Task completion status, only 'pending' or 'done' values allowed.\n  status String\n  \n  /// Timestamp when the todo item was created.\n  created_at DateTime @db.Timestamptz\n  \n  /// Timestamp when the todo item was last updated.\n  updated_at DateTime @db.Timestamptz\n  \n  //----\n  // RELATIONS\n  //----\n  user todo_list_app_users @relation(fields: [todo_list_app_user_id], references: [id], onDelete: Cascade)\n  \n  @@index([todo_list_app_user_id, created_at])\n  @@index([description(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}"},"result":{"success":true,"data":{"files":[{"filename":"schema-01-actors.prisma","namespace":"Actors","models":[{"name":"todo_list_app_users","description":"User accounts for the Todo List Application, storing authentication data including email, password hash, email verification status, and timestamps. This entity represents individual users who own todo items. The table supports soft deletion for account recovery and provides audit fields for tracking creation and modification times. Email is unique allowing identification and login. Relates to todo_list_app_todo_items for ownership of tasks.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[],"plainFields":[{"name":"email","type":"string","nullable":false,"description":"User's unique email address used for login and identity verification."},{"name":"password_hash","type":"string","nullable":false,"description":"Hashed password for user authentication, never store plain text passwords."},{"name":"email_verified","type":"boolean","nullable":false,"description":"Flag indicating whether the user's email address has been verified."},{"name":"created_at","type":"datetime","nullable":false,"description":"Timestamp when the user account was created."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Timestamp when the user account was last updated."},{"name":"deleted_at","type":"datetime","nullable":true,"description":"Timestamp indicating when the user account was soft deleted, if applicable."}],"uniqueIndexes":[{"fieldNames":["email"],"unique":true}],"plainIndexes":[{"fieldNames":["created_at"]}],"ginIndexes":[]}]},{"filename":"schema-02-todo.prisma","namespace":"Todo","models":[{"name":"todo_list_app_todo_items","description":"Represents individual todo items created and managed by users in the todo list application. Each item is tied exclusively to one user, with a status indicating completion state and timestamps for creation and last update. This model enables users to independently create, view, update, and delete their tasks while enforcing ownership and access control. It references the users table for ownership association.","material":false,"stance":"primary","primaryField":{"name":"id","type":"uuid","description":"Primary Key."},"foreignFields":[{"name":"todo_list_app_user_id","type":"uuid","description":"Owning user's {@link todo_list_app_users.id}.","relation":{"name":"user","targetModel":"todo_list_app_users"},"unique":false,"nullable":false}],"plainFields":[{"name":"description","type":"string","nullable":false,"description":"Task description text. Non-empty string up to 256 characters, validated by application logic."},{"name":"status","type":"string","nullable":false,"description":"Task completion status, only 'pending' or 'done' values allowed."},{"name":"created_at","type":"datetime","nullable":false,"description":"Timestamp when the todo item was created."},{"name":"updated_at","type":"datetime","nullable":false,"description":"Timestamp when the todo item was last updated."}],"uniqueIndexes":[],"plainIndexes":[{"fieldNames":["todo_list_app_user_id","created_at"]}],"ginIndexes":[{"fieldName":"description"}]}]}]}},"compiled":{"type":"success","schemas":{"schema-01-actors.prisma":"/// User accounts for the Todo List Application, storing authentication data\n/// including email, password hash, email verification status, and\n/// timestamps. This entity represents individual users who own todo items.\n/// The table supports soft deletion for account recovery and provides audit\n/// fields for tracking creation and modification times. Email is unique\n/// allowing identification and login. Relates to todo_list_app_todo_items\n/// for ownership of tasks.\n///\n/// @namespace Actors\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_app_users {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// User's unique email address used for login and identity verification.\n  email String\n\n  /// Hashed password for user authentication, never store plain text passwords.\n  password_hash String\n\n  /// Flag indicating whether the user's email address has been verified.\n  email_verified Boolean\n\n  /// Timestamp when the user account was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the user account was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  /// Timestamp indicating when the user account was soft deleted, if\n  /// applicable.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  todo_list_app_todo_items todo_list_app_todo_items[]\n\n  @@unique([email])\n  @@index([created_at])\n}\n","schema-02-todo.prisma":"/// Represents individual todo items created and managed by users in the todo\n/// list application. Each item is tied exclusively to one user, with a\n/// status indicating completion state and timestamps for creation and last\n/// update. This model enables users to independently create, view, update,\n/// and delete their tasks while enforcing ownership and access control. It\n/// references the users table for ownership association.\n///\n/// @namespace Todo\n/// @author AutoBE - https://github.com/wrtnlabs/autobe\nmodel todo_list_app_todo_items {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Owning user's {@link todo_list_app_users.id}.\n  todo_list_app_user_id String @db.Uuid\n\n  /// Task description text. Non-empty string up to 256 characters, validated\n  /// by application logic.\n  description String\n\n  /// Task completion status, only 'pending' or 'done' values allowed.\n  status String\n\n  /// Timestamp when the todo item was created.\n  created_at DateTime @db.Timestamptz\n\n  /// Timestamp when the todo item was last updated.\n  updated_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  user todo_list_app_users @relation(fields: [todo_list_app_user_id], references: [id], onDelete: Cascade)\n\n  @@index([todo_list_app_user_id, created_at])\n  @@index([description(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}\n","main.prisma":"generator client {\n  provider        = \"prisma-client-js\"\n  engineType      = \"client\"\n  previewFeatures = [\"postgresqlExtensions\", \"views\"]\n}\n\ndatasource db {\n  provider   = \"postgresql\"\n  url        = env(\"DATABASE_URL\")\n  extensions = [pg_trgm]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  output   = \"../../docs/ERD.md\"\n}\n"},"nodeModules":{"node_modules/.prisma/client/client.d.ts":"export * from \"./index\"","node_modules/.prisma/client/default.d.ts":"export * from \"./index\"","node_modules/.prisma/client/edge.d.ts":"export * from \"./default\"","node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/client.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model todo_list_app_users\n * User accounts for the Todo List Application, storing authentication data\n * including email, password hash, email verification status, and\n * timestamps. This entity represents individual users who own todo items.\n * The table supports soft deletion for account recovery and provides audit\n * fields for tracking creation and modification times. Email is unique\n * allowing identification and login. Relates to todo_list_app_todo_items\n * for ownership of tasks.\n * \n * @namespace Actors\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_app_users = $Result.DefaultSelection<Prisma.$todo_list_app_usersPayload>\n/**\n * Model todo_list_app_todo_items\n * Represents individual todo items created and managed by users in the todo\n * list application. Each item is tied exclusively to one user, with a\n * status indicating completion state and timestamps for creation and last\n * update. This model enables users to independently create, view, update,\n * and delete their tasks while enforcing ownership and access control. It\n * references the users table for ownership association.\n * \n * @namespace Todo\n * @author AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type todo_list_app_todo_items = $Result.DefaultSelection<Prisma.$todo_list_app_todo_itemsPayload>\n\n/**\n * ##  Prisma Client ʲˢ\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Todo_list_app_users\n * const todo_list_app_users = await prisma.todo_list_app_users.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ʲˢ\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Todo_list_app_users\n   * const todo_list_app_users = await prisma.todo_list_app_users.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.todo_list_app_users`: Exposes CRUD operations for the **todo_list_app_users** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_app_users\n    * const todo_list_app_users = await prisma.todo_list_app_users.findMany()\n    * ```\n    */\n  get todo_list_app_users(): Prisma.todo_list_app_usersDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.todo_list_app_todo_items`: Exposes CRUD operations for the **todo_list_app_todo_items** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Todo_list_app_todo_items\n    * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.findMany()\n    * ```\n    */\n  get todo_list_app_todo_items(): Prisma.todo_list_app_todo_itemsDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: local\n   * Query Engine version: local\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    todo_list_app_users: 'todo_list_app_users',\n    todo_list_app_todo_items: 'todo_list_app_todo_items'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"todo_list_app_users\" | \"todo_list_app_todo_items\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      todo_list_app_users: {\n        payload: Prisma.$todo_list_app_usersPayload<ExtArgs>\n        fields: Prisma.todo_list_app_usersFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_app_usersFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_app_usersFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_app_usersFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_app_usersFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_app_usersFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_app_usersCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_app_usersCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_app_usersCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_app_usersDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>\n          }\n          update: {\n            args: Prisma.todo_list_app_usersUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_app_usersDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_app_usersUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_app_usersUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_app_usersUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_usersPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_app_usersAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_app_users>\n          }\n          groupBy: {\n            args: Prisma.todo_list_app_usersGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_app_usersGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_app_usersCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_app_usersCountAggregateOutputType> | number\n          }\n        }\n      }\n      todo_list_app_todo_items: {\n        payload: Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>\n        fields: Prisma.todo_list_app_todo_itemsFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.todo_list_app_todo_itemsFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.todo_list_app_todo_itemsFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>\n          }\n          findFirst: {\n            args: Prisma.todo_list_app_todo_itemsFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.todo_list_app_todo_itemsFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>\n          }\n          findMany: {\n            args: Prisma.todo_list_app_todo_itemsFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>[]\n          }\n          create: {\n            args: Prisma.todo_list_app_todo_itemsCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>\n          }\n          createMany: {\n            args: Prisma.todo_list_app_todo_itemsCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.todo_list_app_todo_itemsCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>[]\n          }\n          delete: {\n            args: Prisma.todo_list_app_todo_itemsDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>\n          }\n          update: {\n            args: Prisma.todo_list_app_todo_itemsUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>\n          }\n          deleteMany: {\n            args: Prisma.todo_list_app_todo_itemsDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.todo_list_app_todo_itemsUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.todo_list_app_todo_itemsUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>[]\n          }\n          upsert: {\n            args: Prisma.todo_list_app_todo_itemsUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$todo_list_app_todo_itemsPayload>\n          }\n          aggregate: {\n            args: Prisma.Todo_list_app_todo_itemsAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateTodo_list_app_todo_items>\n          }\n          groupBy: {\n            args: Prisma.todo_list_app_todo_itemsGroupByArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_app_todo_itemsGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.todo_list_app_todo_itemsCountArgs<ExtArgs>\n            result: $Utils.Optional<Todo_list_app_todo_itemsCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Shorthand for `emit: 'stdout'`\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events only\n     * log: [\n     *   { emit: 'event', level: 'query' },\n     *   { emit: 'event', level: 'info' },\n     *   { emit: 'event', level: 'warn' }\n     *   { emit: 'event', level: 'error' }\n     * ]\n     * \n     * / Emit as events and log to stdout\n     * og: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * \n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`\n     */\n    adapter?: runtime.SqlDriverAdapterFactory | null\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    todo_list_app_users?: todo_list_app_usersOmit\n    todo_list_app_todo_items?: todo_list_app_todo_itemsOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\n  export type GetLogType<T> = CheckIsLogLevel<\n    T extends LogDefinition ? T['level'] : T\n  >;\n\n  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n    ? GetLogType<T[number]>\n    : never;\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type Todo_list_app_usersCountOutputType\n   */\n\n  export type Todo_list_app_usersCountOutputType = {\n    todo_list_app_todo_items: number\n  }\n\n  export type Todo_list_app_usersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_app_todo_items?: boolean | Todo_list_app_usersCountOutputTypeCountTodo_list_app_todo_itemsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * Todo_list_app_usersCountOutputType without action\n   */\n  export type Todo_list_app_usersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Todo_list_app_usersCountOutputType\n     */\n    select?: Todo_list_app_usersCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * Todo_list_app_usersCountOutputType without action\n   */\n  export type Todo_list_app_usersCountOutputTypeCountTodo_list_app_todo_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_app_todo_itemsWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model todo_list_app_users\n   */\n\n  export type AggregateTodo_list_app_users = {\n    _count: Todo_list_app_usersCountAggregateOutputType | null\n    _min: Todo_list_app_usersMinAggregateOutputType | null\n    _max: Todo_list_app_usersMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_app_usersMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    email_verified: boolean | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_list_app_usersMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    password_hash: string | null\n    email_verified: boolean | null\n    created_at: Date | null\n    updated_at: Date | null\n    deleted_at: Date | null\n  }\n\n  export type Todo_list_app_usersCountAggregateOutputType = {\n    id: number\n    email: number\n    password_hash: number\n    email_verified: number\n    created_at: number\n    updated_at: number\n    deleted_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_app_usersMinAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    email_verified?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_list_app_usersMaxAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    email_verified?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n  }\n\n  export type Todo_list_app_usersCountAggregateInputType = {\n    id?: true\n    email?: true\n    password_hash?: true\n    email_verified?: true\n    created_at?: true\n    updated_at?: true\n    deleted_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_app_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_app_users to aggregate.\n     */\n    where?: todo_list_app_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_app_users to fetch.\n     */\n    orderBy?: todo_list_app_usersOrderByWithRelationInput | todo_list_app_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_app_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_app_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_app_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_app_users\n    **/\n    _count?: true | Todo_list_app_usersCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_app_usersMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_app_usersMaxAggregateInputType\n  }\n\n  export type GetTodo_list_app_usersAggregateType<T extends Todo_list_app_usersAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_app_users]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_app_users[P]>\n      : GetScalarType<T[P], AggregateTodo_list_app_users[P]>\n  }\n\n\n\n\n  export type todo_list_app_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_app_usersWhereInput\n    orderBy?: todo_list_app_usersOrderByWithAggregationInput | todo_list_app_usersOrderByWithAggregationInput[]\n    by: Todo_list_app_usersScalarFieldEnum[] | Todo_list_app_usersScalarFieldEnum\n    having?: todo_list_app_usersScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_app_usersCountAggregateInputType | true\n    _min?: Todo_list_app_usersMinAggregateInputType\n    _max?: Todo_list_app_usersMaxAggregateInputType\n  }\n\n  export type Todo_list_app_usersGroupByOutputType = {\n    id: string\n    email: string\n    password_hash: string\n    email_verified: boolean\n    created_at: Date\n    updated_at: Date\n    deleted_at: Date | null\n    _count: Todo_list_app_usersCountAggregateOutputType | null\n    _min: Todo_list_app_usersMinAggregateOutputType | null\n    _max: Todo_list_app_usersMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_app_usersGroupByPayload<T extends todo_list_app_usersGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_app_usersGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_app_usersGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_app_usersGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_app_usersGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_app_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    email_verified?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n    todo_list_app_todo_items?: boolean | todo_list_app_users$todo_list_app_todo_itemsArgs<ExtArgs>\n    _count?: boolean | Todo_list_app_usersCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_app_users\"]>\n\n  export type todo_list_app_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    email_verified?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_app_users\"]>\n\n  export type todo_list_app_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    email_verified?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }, ExtArgs[\"result\"][\"todo_list_app_users\"]>\n\n  export type todo_list_app_usersSelectScalar = {\n    id?: boolean\n    email?: boolean\n    password_hash?: boolean\n    email_verified?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    deleted_at?: boolean\n  }\n\n  export type todo_list_app_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"password_hash\" | \"email_verified\" | \"created_at\" | \"updated_at\" | \"deleted_at\", ExtArgs[\"result\"][\"todo_list_app_users\"]>\n  export type todo_list_app_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    todo_list_app_todo_items?: boolean | todo_list_app_users$todo_list_app_todo_itemsArgs<ExtArgs>\n    _count?: boolean | Todo_list_app_usersCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type todo_list_app_usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type todo_list_app_usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $todo_list_app_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_app_users\"\n    objects: {\n      todo_list_app_todo_items: Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * User's unique email address used for login and identity verification.\n       */\n      email: string\n      /**\n       * Hashed password for user authentication, never store plain text passwords.\n       */\n      password_hash: string\n      /**\n       * Flag indicating whether the user's email address has been verified.\n       */\n      email_verified: boolean\n      /**\n       * Timestamp when the user account was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the user account was last updated.\n       */\n      updated_at: Date\n      /**\n       * Timestamp indicating when the user account was soft deleted, if\n       * applicable.\n       */\n      deleted_at: Date | null\n    }, ExtArgs[\"result\"][\"todo_list_app_users\"]>\n    composites: {}\n  }\n\n  type todo_list_app_usersGetPayload<S extends boolean | null | undefined | todo_list_app_usersDefaultArgs> = $Result.GetResult<Prisma.$todo_list_app_usersPayload, S>\n\n  type todo_list_app_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_app_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_app_usersCountAggregateInputType | true\n    }\n\n  export interface todo_list_app_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_app_users'], meta: { name: 'todo_list_app_users' } }\n    /**\n     * Find zero or one Todo_list_app_users that matches the filter.\n     * @param {todo_list_app_usersFindUniqueArgs} args - Arguments to find a Todo_list_app_users\n     * @example\n     * // Get one Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_app_usersFindUniqueArgs>(args: SelectSubset<T, todo_list_app_usersFindUniqueArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_app_users that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_app_usersFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_app_users\n     * @example\n     * // Get one Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_app_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_app_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_app_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_usersFindFirstArgs} args - Arguments to find a Todo_list_app_users\n     * @example\n     * // Get one Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_app_usersFindFirstArgs>(args?: SelectSubset<T, todo_list_app_usersFindFirstArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_app_users that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_usersFindFirstOrThrowArgs} args - Arguments to find a Todo_list_app_users\n     * @example\n     * // Get one Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_app_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_app_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_app_users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_usersFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.findMany()\n     * \n     * // Get first 10 Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_app_usersWithIdOnly = await prisma.todo_list_app_users.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_app_usersFindManyArgs>(args?: SelectSubset<T, todo_list_app_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_app_users.\n     * @param {todo_list_app_usersCreateArgs} args - Arguments to create a Todo_list_app_users.\n     * @example\n     * // Create one Todo_list_app_users\n     * const Todo_list_app_users = await prisma.todo_list_app_users.create({\n     *   data: {\n     *     // ... data to create a Todo_list_app_users\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_app_usersCreateArgs>(args: SelectSubset<T, todo_list_app_usersCreateArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_app_users.\n     * @param {todo_list_app_usersCreateManyArgs} args - Arguments to create many Todo_list_app_users.\n     * @example\n     * // Create many Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_app_usersCreateManyArgs>(args?: SelectSubset<T, todo_list_app_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_app_users and returns the data saved in the database.\n     * @param {todo_list_app_usersCreateManyAndReturnArgs} args - Arguments to create many Todo_list_app_users.\n     * @example\n     * // Create many Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_app_users and only return the `id`\n     * const todo_list_app_usersWithIdOnly = await prisma.todo_list_app_users.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_app_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_app_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_app_users.\n     * @param {todo_list_app_usersDeleteArgs} args - Arguments to delete one Todo_list_app_users.\n     * @example\n     * // Delete one Todo_list_app_users\n     * const Todo_list_app_users = await prisma.todo_list_app_users.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_app_users\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_app_usersDeleteArgs>(args: SelectSubset<T, todo_list_app_usersDeleteArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_app_users.\n     * @param {todo_list_app_usersUpdateArgs} args - Arguments to update one Todo_list_app_users.\n     * @example\n     * // Update one Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_app_usersUpdateArgs>(args: SelectSubset<T, todo_list_app_usersUpdateArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_app_users.\n     * @param {todo_list_app_usersDeleteManyArgs} args - Arguments to filter Todo_list_app_users to delete.\n     * @example\n     * // Delete a few Todo_list_app_users\n     * const { count } = await prisma.todo_list_app_users.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_app_usersDeleteManyArgs>(args?: SelectSubset<T, todo_list_app_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_app_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_usersUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_app_usersUpdateManyArgs>(args: SelectSubset<T, todo_list_app_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_app_users and returns the data updated in the database.\n     * @param {todo_list_app_usersUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_app_users.\n     * @example\n     * // Update many Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_app_users and only return the `id`\n     * const todo_list_app_usersWithIdOnly = await prisma.todo_list_app_users.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_app_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_app_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_app_users.\n     * @param {todo_list_app_usersUpsertArgs} args - Arguments to update or create a Todo_list_app_users.\n     * @example\n     * // Update or create a Todo_list_app_users\n     * const todo_list_app_users = await prisma.todo_list_app_users.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_app_users\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_app_users we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_app_usersUpsertArgs>(args: SelectSubset<T, todo_list_app_usersUpsertArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_app_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_usersCountArgs} args - Arguments to filter Todo_list_app_users to count.\n     * @example\n     * // Count the number of Todo_list_app_users\n     * const count = await prisma.todo_list_app_users.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_app_users we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_app_usersCountArgs>(\n      args?: Subset<T, todo_list_app_usersCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_app_usersCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_app_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_app_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_app_usersAggregateArgs>(args: Subset<T, Todo_list_app_usersAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_app_usersAggregateType<T>>\n\n    /**\n     * Group by Todo_list_app_users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_usersGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_app_usersGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_app_usersGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_app_usersGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_app_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_app_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_app_users model\n   */\n  readonly fields: todo_list_app_usersFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_app_users.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_app_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    todo_list_app_todo_items<T extends todo_list_app_users$todo_list_app_todo_itemsArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_app_users$todo_list_app_todo_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_app_users model\n   */\n  interface todo_list_app_usersFieldRefs {\n    readonly id: FieldRef<\"todo_list_app_users\", 'String'>\n    readonly email: FieldRef<\"todo_list_app_users\", 'String'>\n    readonly password_hash: FieldRef<\"todo_list_app_users\", 'String'>\n    readonly email_verified: FieldRef<\"todo_list_app_users\", 'Boolean'>\n    readonly created_at: FieldRef<\"todo_list_app_users\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_app_users\", 'DateTime'>\n    readonly deleted_at: FieldRef<\"todo_list_app_users\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_app_users findUnique\n   */\n  export type todo_list_app_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_users to fetch.\n     */\n    where: todo_list_app_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_app_users findUniqueOrThrow\n   */\n  export type todo_list_app_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_users to fetch.\n     */\n    where: todo_list_app_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_app_users findFirst\n   */\n  export type todo_list_app_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_users to fetch.\n     */\n    where?: todo_list_app_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_app_users to fetch.\n     */\n    orderBy?: todo_list_app_usersOrderByWithRelationInput | todo_list_app_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_app_users.\n     */\n    cursor?: todo_list_app_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_app_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_app_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_app_users.\n     */\n    distinct?: Todo_list_app_usersScalarFieldEnum | Todo_list_app_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_app_users findFirstOrThrow\n   */\n  export type todo_list_app_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_users to fetch.\n     */\n    where?: todo_list_app_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_app_users to fetch.\n     */\n    orderBy?: todo_list_app_usersOrderByWithRelationInput | todo_list_app_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_app_users.\n     */\n    cursor?: todo_list_app_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_app_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_app_users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_app_users.\n     */\n    distinct?: Todo_list_app_usersScalarFieldEnum | Todo_list_app_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_app_users findMany\n   */\n  export type todo_list_app_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_users to fetch.\n     */\n    where?: todo_list_app_usersWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_app_users to fetch.\n     */\n    orderBy?: todo_list_app_usersOrderByWithRelationInput | todo_list_app_usersOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_app_users.\n     */\n    cursor?: todo_list_app_usersWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_app_users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_app_users.\n     */\n    skip?: number\n    distinct?: Todo_list_app_usersScalarFieldEnum | Todo_list_app_usersScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_app_users create\n   */\n  export type todo_list_app_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_app_users.\n     */\n    data: XOR<todo_list_app_usersCreateInput, todo_list_app_usersUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_app_users createMany\n   */\n  export type todo_list_app_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_app_users.\n     */\n    data: todo_list_app_usersCreateManyInput | todo_list_app_usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_app_users createManyAndReturn\n   */\n  export type todo_list_app_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_app_users.\n     */\n    data: todo_list_app_usersCreateManyInput | todo_list_app_usersCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_app_users update\n   */\n  export type todo_list_app_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_app_users.\n     */\n    data: XOR<todo_list_app_usersUpdateInput, todo_list_app_usersUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_app_users to update.\n     */\n    where: todo_list_app_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_app_users updateMany\n   */\n  export type todo_list_app_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_app_users.\n     */\n    data: XOR<todo_list_app_usersUpdateManyMutationInput, todo_list_app_usersUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_app_users to update\n     */\n    where?: todo_list_app_usersWhereInput\n    /**\n     * Limit how many todo_list_app_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_app_users updateManyAndReturn\n   */\n  export type todo_list_app_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_app_users.\n     */\n    data: XOR<todo_list_app_usersUpdateManyMutationInput, todo_list_app_usersUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_app_users to update\n     */\n    where?: todo_list_app_usersWhereInput\n    /**\n     * Limit how many todo_list_app_users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_app_users upsert\n   */\n  export type todo_list_app_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_app_users to update in case it exists.\n     */\n    where: todo_list_app_usersWhereUniqueInput\n    /**\n     * In case the todo_list_app_users found by the `where` argument doesn't exist, create a new todo_list_app_users with this data.\n     */\n    create: XOR<todo_list_app_usersCreateInput, todo_list_app_usersUncheckedCreateInput>\n    /**\n     * In case the todo_list_app_users was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_app_usersUpdateInput, todo_list_app_usersUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_app_users delete\n   */\n  export type todo_list_app_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_app_users to delete.\n     */\n    where: todo_list_app_usersWhereUniqueInput\n  }\n\n  /**\n   * todo_list_app_users deleteMany\n   */\n  export type todo_list_app_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_app_users to delete\n     */\n    where?: todo_list_app_usersWhereInput\n    /**\n     * Limit how many todo_list_app_users to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_app_users.todo_list_app_todo_items\n   */\n  export type todo_list_app_users$todo_list_app_todo_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    where?: todo_list_app_todo_itemsWhereInput\n    orderBy?: todo_list_app_todo_itemsOrderByWithRelationInput | todo_list_app_todo_itemsOrderByWithRelationInput[]\n    cursor?: todo_list_app_todo_itemsWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: Todo_list_app_todo_itemsScalarFieldEnum | Todo_list_app_todo_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_app_users without action\n   */\n  export type todo_list_app_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_users\n     */\n    select?: todo_list_app_usersSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_users\n     */\n    omit?: todo_list_app_usersOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_usersInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model todo_list_app_todo_items\n   */\n\n  export type AggregateTodo_list_app_todo_items = {\n    _count: Todo_list_app_todo_itemsCountAggregateOutputType | null\n    _min: Todo_list_app_todo_itemsMinAggregateOutputType | null\n    _max: Todo_list_app_todo_itemsMaxAggregateOutputType | null\n  }\n\n  export type Todo_list_app_todo_itemsMinAggregateOutputType = {\n    id: string | null\n    todo_list_app_user_id: string | null\n    description: string | null\n    status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Todo_list_app_todo_itemsMaxAggregateOutputType = {\n    id: string | null\n    todo_list_app_user_id: string | null\n    description: string | null\n    status: string | null\n    created_at: Date | null\n    updated_at: Date | null\n  }\n\n  export type Todo_list_app_todo_itemsCountAggregateOutputType = {\n    id: number\n    todo_list_app_user_id: number\n    description: number\n    status: number\n    created_at: number\n    updated_at: number\n    _all: number\n  }\n\n\n  export type Todo_list_app_todo_itemsMinAggregateInputType = {\n    id?: true\n    todo_list_app_user_id?: true\n    description?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Todo_list_app_todo_itemsMaxAggregateInputType = {\n    id?: true\n    todo_list_app_user_id?: true\n    description?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n  }\n\n  export type Todo_list_app_todo_itemsCountAggregateInputType = {\n    id?: true\n    todo_list_app_user_id?: true\n    description?: true\n    status?: true\n    created_at?: true\n    updated_at?: true\n    _all?: true\n  }\n\n  export type Todo_list_app_todo_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_app_todo_items to aggregate.\n     */\n    where?: todo_list_app_todo_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_app_todo_items to fetch.\n     */\n    orderBy?: todo_list_app_todo_itemsOrderByWithRelationInput | todo_list_app_todo_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: todo_list_app_todo_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_app_todo_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_app_todo_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned todo_list_app_todo_items\n    **/\n    _count?: true | Todo_list_app_todo_itemsCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: Todo_list_app_todo_itemsMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: Todo_list_app_todo_itemsMaxAggregateInputType\n  }\n\n  export type GetTodo_list_app_todo_itemsAggregateType<T extends Todo_list_app_todo_itemsAggregateArgs> = {\n        [P in keyof T & keyof AggregateTodo_list_app_todo_items]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateTodo_list_app_todo_items[P]>\n      : GetScalarType<T[P], AggregateTodo_list_app_todo_items[P]>\n  }\n\n\n\n\n  export type todo_list_app_todo_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: todo_list_app_todo_itemsWhereInput\n    orderBy?: todo_list_app_todo_itemsOrderByWithAggregationInput | todo_list_app_todo_itemsOrderByWithAggregationInput[]\n    by: Todo_list_app_todo_itemsScalarFieldEnum[] | Todo_list_app_todo_itemsScalarFieldEnum\n    having?: todo_list_app_todo_itemsScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: Todo_list_app_todo_itemsCountAggregateInputType | true\n    _min?: Todo_list_app_todo_itemsMinAggregateInputType\n    _max?: Todo_list_app_todo_itemsMaxAggregateInputType\n  }\n\n  export type Todo_list_app_todo_itemsGroupByOutputType = {\n    id: string\n    todo_list_app_user_id: string\n    description: string\n    status: string\n    created_at: Date\n    updated_at: Date\n    _count: Todo_list_app_todo_itemsCountAggregateOutputType | null\n    _min: Todo_list_app_todo_itemsMinAggregateOutputType | null\n    _max: Todo_list_app_todo_itemsMaxAggregateOutputType | null\n  }\n\n  type GetTodo_list_app_todo_itemsGroupByPayload<T extends todo_list_app_todo_itemsGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<Todo_list_app_todo_itemsGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof Todo_list_app_todo_itemsGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], Todo_list_app_todo_itemsGroupByOutputType[P]>\n            : GetScalarType<T[P], Todo_list_app_todo_itemsGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type todo_list_app_todo_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_app_user_id?: boolean\n    description?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    user?: boolean | todo_list_app_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_app_todo_items\"]>\n\n  export type todo_list_app_todo_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_app_user_id?: boolean\n    description?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    user?: boolean | todo_list_app_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_app_todo_items\"]>\n\n  export type todo_list_app_todo_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    todo_list_app_user_id?: boolean\n    description?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n    user?: boolean | todo_list_app_usersDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"todo_list_app_todo_items\"]>\n\n  export type todo_list_app_todo_itemsSelectScalar = {\n    id?: boolean\n    todo_list_app_user_id?: boolean\n    description?: boolean\n    status?: boolean\n    created_at?: boolean\n    updated_at?: boolean\n  }\n\n  export type todo_list_app_todo_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"todo_list_app_user_id\" | \"description\" | \"status\" | \"created_at\" | \"updated_at\", ExtArgs[\"result\"][\"todo_list_app_todo_items\"]>\n  export type todo_list_app_todo_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_app_usersDefaultArgs<ExtArgs>\n  }\n  export type todo_list_app_todo_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_app_usersDefaultArgs<ExtArgs>\n  }\n  export type todo_list_app_todo_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | todo_list_app_usersDefaultArgs<ExtArgs>\n  }\n\n  export type $todo_list_app_todo_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"todo_list_app_todo_items\"\n    objects: {\n      user: Prisma.$todo_list_app_usersPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      /**\n       * Primary Key.\n       */\n      id: string\n      /**\n       * Owning user's {@link todo_list_app_users.id}.\n       */\n      todo_list_app_user_id: string\n      /**\n       * Task description text. Non-empty string up to 256 characters, validated\n       * by application logic.\n       */\n      description: string\n      /**\n       * Task completion status, only 'pending' or 'done' values allowed.\n       */\n      status: string\n      /**\n       * Timestamp when the todo item was created.\n       */\n      created_at: Date\n      /**\n       * Timestamp when the todo item was last updated.\n       */\n      updated_at: Date\n    }, ExtArgs[\"result\"][\"todo_list_app_todo_items\"]>\n    composites: {}\n  }\n\n  type todo_list_app_todo_itemsGetPayload<S extends boolean | null | undefined | todo_list_app_todo_itemsDefaultArgs> = $Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload, S>\n\n  type todo_list_app_todo_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<todo_list_app_todo_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: Todo_list_app_todo_itemsCountAggregateInputType | true\n    }\n\n  export interface todo_list_app_todo_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo_list_app_todo_items'], meta: { name: 'todo_list_app_todo_items' } }\n    /**\n     * Find zero or one Todo_list_app_todo_items that matches the filter.\n     * @param {todo_list_app_todo_itemsFindUniqueArgs} args - Arguments to find a Todo_list_app_todo_items\n     * @example\n     * // Get one Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends todo_list_app_todo_itemsFindUniqueArgs>(args: SelectSubset<T, todo_list_app_todo_itemsFindUniqueArgs<ExtArgs>>): Prisma__todo_list_app_todo_itemsClient<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Todo_list_app_todo_items that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {todo_list_app_todo_itemsFindUniqueOrThrowArgs} args - Arguments to find a Todo_list_app_todo_items\n     * @example\n     * // Get one Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends todo_list_app_todo_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, todo_list_app_todo_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todo_list_app_todo_itemsClient<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_app_todo_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_todo_itemsFindFirstArgs} args - Arguments to find a Todo_list_app_todo_items\n     * @example\n     * // Get one Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends todo_list_app_todo_itemsFindFirstArgs>(args?: SelectSubset<T, todo_list_app_todo_itemsFindFirstArgs<ExtArgs>>): Prisma__todo_list_app_todo_itemsClient<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Todo_list_app_todo_items that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_todo_itemsFindFirstOrThrowArgs} args - Arguments to find a Todo_list_app_todo_items\n     * @example\n     * // Get one Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends todo_list_app_todo_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, todo_list_app_todo_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__todo_list_app_todo_itemsClient<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Todo_list_app_todo_items that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_todo_itemsFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.findMany()\n     * \n     * // Get first 10 Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const todo_list_app_todo_itemsWithIdOnly = await prisma.todo_list_app_todo_items.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends todo_list_app_todo_itemsFindManyArgs>(args?: SelectSubset<T, todo_list_app_todo_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Todo_list_app_todo_items.\n     * @param {todo_list_app_todo_itemsCreateArgs} args - Arguments to create a Todo_list_app_todo_items.\n     * @example\n     * // Create one Todo_list_app_todo_items\n     * const Todo_list_app_todo_items = await prisma.todo_list_app_todo_items.create({\n     *   data: {\n     *     // ... data to create a Todo_list_app_todo_items\n     *   }\n     * })\n     * \n     */\n    create<T extends todo_list_app_todo_itemsCreateArgs>(args: SelectSubset<T, todo_list_app_todo_itemsCreateArgs<ExtArgs>>): Prisma__todo_list_app_todo_itemsClient<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Todo_list_app_todo_items.\n     * @param {todo_list_app_todo_itemsCreateManyArgs} args - Arguments to create many Todo_list_app_todo_items.\n     * @example\n     * // Create many Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends todo_list_app_todo_itemsCreateManyArgs>(args?: SelectSubset<T, todo_list_app_todo_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Todo_list_app_todo_items and returns the data saved in the database.\n     * @param {todo_list_app_todo_itemsCreateManyAndReturnArgs} args - Arguments to create many Todo_list_app_todo_items.\n     * @example\n     * // Create many Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Todo_list_app_todo_items and only return the `id`\n     * const todo_list_app_todo_itemsWithIdOnly = await prisma.todo_list_app_todo_items.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends todo_list_app_todo_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, todo_list_app_todo_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Todo_list_app_todo_items.\n     * @param {todo_list_app_todo_itemsDeleteArgs} args - Arguments to delete one Todo_list_app_todo_items.\n     * @example\n     * // Delete one Todo_list_app_todo_items\n     * const Todo_list_app_todo_items = await prisma.todo_list_app_todo_items.delete({\n     *   where: {\n     *     // ... filter to delete one Todo_list_app_todo_items\n     *   }\n     * })\n     * \n     */\n    delete<T extends todo_list_app_todo_itemsDeleteArgs>(args: SelectSubset<T, todo_list_app_todo_itemsDeleteArgs<ExtArgs>>): Prisma__todo_list_app_todo_itemsClient<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Todo_list_app_todo_items.\n     * @param {todo_list_app_todo_itemsUpdateArgs} args - Arguments to update one Todo_list_app_todo_items.\n     * @example\n     * // Update one Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends todo_list_app_todo_itemsUpdateArgs>(args: SelectSubset<T, todo_list_app_todo_itemsUpdateArgs<ExtArgs>>): Prisma__todo_list_app_todo_itemsClient<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Todo_list_app_todo_items.\n     * @param {todo_list_app_todo_itemsDeleteManyArgs} args - Arguments to filter Todo_list_app_todo_items to delete.\n     * @example\n     * // Delete a few Todo_list_app_todo_items\n     * const { count } = await prisma.todo_list_app_todo_items.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends todo_list_app_todo_itemsDeleteManyArgs>(args?: SelectSubset<T, todo_list_app_todo_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_app_todo_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_todo_itemsUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends todo_list_app_todo_itemsUpdateManyArgs>(args: SelectSubset<T, todo_list_app_todo_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Todo_list_app_todo_items and returns the data updated in the database.\n     * @param {todo_list_app_todo_itemsUpdateManyAndReturnArgs} args - Arguments to update many Todo_list_app_todo_items.\n     * @example\n     * // Update many Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Todo_list_app_todo_items and only return the `id`\n     * const todo_list_app_todo_itemsWithIdOnly = await prisma.todo_list_app_todo_items.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends todo_list_app_todo_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, todo_list_app_todo_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Todo_list_app_todo_items.\n     * @param {todo_list_app_todo_itemsUpsertArgs} args - Arguments to update or create a Todo_list_app_todo_items.\n     * @example\n     * // Update or create a Todo_list_app_todo_items\n     * const todo_list_app_todo_items = await prisma.todo_list_app_todo_items.upsert({\n     *   create: {\n     *     // ... data to create a Todo_list_app_todo_items\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Todo_list_app_todo_items we want to update\n     *   }\n     * })\n     */\n    upsert<T extends todo_list_app_todo_itemsUpsertArgs>(args: SelectSubset<T, todo_list_app_todo_itemsUpsertArgs<ExtArgs>>): Prisma__todo_list_app_todo_itemsClient<$Result.GetResult<Prisma.$todo_list_app_todo_itemsPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Todo_list_app_todo_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_todo_itemsCountArgs} args - Arguments to filter Todo_list_app_todo_items to count.\n     * @example\n     * // Count the number of Todo_list_app_todo_items\n     * const count = await prisma.todo_list_app_todo_items.count({\n     *   where: {\n     *     // ... the filter for the Todo_list_app_todo_items we want to count\n     *   }\n     * })\n    **/\n    count<T extends todo_list_app_todo_itemsCountArgs>(\n      args?: Subset<T, todo_list_app_todo_itemsCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], Todo_list_app_todo_itemsCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Todo_list_app_todo_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {Todo_list_app_todo_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends Todo_list_app_todo_itemsAggregateArgs>(args: Subset<T, Todo_list_app_todo_itemsAggregateArgs>): Prisma.PrismaPromise<GetTodo_list_app_todo_itemsAggregateType<T>>\n\n    /**\n     * Group by Todo_list_app_todo_items.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {todo_list_app_todo_itemsGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends todo_list_app_todo_itemsGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: todo_list_app_todo_itemsGroupByArgs['orderBy'] }\n        : { orderBy?: todo_list_app_todo_itemsGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, todo_list_app_todo_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodo_list_app_todo_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the todo_list_app_todo_items model\n   */\n  readonly fields: todo_list_app_todo_itemsFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for todo_list_app_todo_items.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__todo_list_app_todo_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends todo_list_app_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, todo_list_app_usersDefaultArgs<ExtArgs>>): Prisma__todo_list_app_usersClient<$Result.GetResult<Prisma.$todo_list_app_usersPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the todo_list_app_todo_items model\n   */\n  interface todo_list_app_todo_itemsFieldRefs {\n    readonly id: FieldRef<\"todo_list_app_todo_items\", 'String'>\n    readonly todo_list_app_user_id: FieldRef<\"todo_list_app_todo_items\", 'String'>\n    readonly description: FieldRef<\"todo_list_app_todo_items\", 'String'>\n    readonly status: FieldRef<\"todo_list_app_todo_items\", 'String'>\n    readonly created_at: FieldRef<\"todo_list_app_todo_items\", 'DateTime'>\n    readonly updated_at: FieldRef<\"todo_list_app_todo_items\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * todo_list_app_todo_items findUnique\n   */\n  export type todo_list_app_todo_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_todo_items to fetch.\n     */\n    where: todo_list_app_todo_itemsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_app_todo_items findUniqueOrThrow\n   */\n  export type todo_list_app_todo_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_todo_items to fetch.\n     */\n    where: todo_list_app_todo_itemsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_app_todo_items findFirst\n   */\n  export type todo_list_app_todo_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_todo_items to fetch.\n     */\n    where?: todo_list_app_todo_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_app_todo_items to fetch.\n     */\n    orderBy?: todo_list_app_todo_itemsOrderByWithRelationInput | todo_list_app_todo_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_app_todo_items.\n     */\n    cursor?: todo_list_app_todo_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_app_todo_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_app_todo_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_app_todo_items.\n     */\n    distinct?: Todo_list_app_todo_itemsScalarFieldEnum | Todo_list_app_todo_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_app_todo_items findFirstOrThrow\n   */\n  export type todo_list_app_todo_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_todo_items to fetch.\n     */\n    where?: todo_list_app_todo_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_app_todo_items to fetch.\n     */\n    orderBy?: todo_list_app_todo_itemsOrderByWithRelationInput | todo_list_app_todo_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for todo_list_app_todo_items.\n     */\n    cursor?: todo_list_app_todo_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_app_todo_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_app_todo_items.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of todo_list_app_todo_items.\n     */\n    distinct?: Todo_list_app_todo_itemsScalarFieldEnum | Todo_list_app_todo_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_app_todo_items findMany\n   */\n  export type todo_list_app_todo_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * Filter, which todo_list_app_todo_items to fetch.\n     */\n    where?: todo_list_app_todo_itemsWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of todo_list_app_todo_items to fetch.\n     */\n    orderBy?: todo_list_app_todo_itemsOrderByWithRelationInput | todo_list_app_todo_itemsOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing todo_list_app_todo_items.\n     */\n    cursor?: todo_list_app_todo_itemsWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` todo_list_app_todo_items from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` todo_list_app_todo_items.\n     */\n    skip?: number\n    distinct?: Todo_list_app_todo_itemsScalarFieldEnum | Todo_list_app_todo_itemsScalarFieldEnum[]\n  }\n\n  /**\n   * todo_list_app_todo_items create\n   */\n  export type todo_list_app_todo_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to create a todo_list_app_todo_items.\n     */\n    data: XOR<todo_list_app_todo_itemsCreateInput, todo_list_app_todo_itemsUncheckedCreateInput>\n  }\n\n  /**\n   * todo_list_app_todo_items createMany\n   */\n  export type todo_list_app_todo_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many todo_list_app_todo_items.\n     */\n    data: todo_list_app_todo_itemsCreateManyInput | todo_list_app_todo_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * todo_list_app_todo_items createManyAndReturn\n   */\n  export type todo_list_app_todo_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to create many todo_list_app_todo_items.\n     */\n    data: todo_list_app_todo_itemsCreateManyInput | todo_list_app_todo_itemsCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_app_todo_items update\n   */\n  export type todo_list_app_todo_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * The data needed to update a todo_list_app_todo_items.\n     */\n    data: XOR<todo_list_app_todo_itemsUpdateInput, todo_list_app_todo_itemsUncheckedUpdateInput>\n    /**\n     * Choose, which todo_list_app_todo_items to update.\n     */\n    where: todo_list_app_todo_itemsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_app_todo_items updateMany\n   */\n  export type todo_list_app_todo_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update todo_list_app_todo_items.\n     */\n    data: XOR<todo_list_app_todo_itemsUpdateManyMutationInput, todo_list_app_todo_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_app_todo_items to update\n     */\n    where?: todo_list_app_todo_itemsWhereInput\n    /**\n     * Limit how many todo_list_app_todo_items to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_app_todo_items updateManyAndReturn\n   */\n  export type todo_list_app_todo_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * The data used to update todo_list_app_todo_items.\n     */\n    data: XOR<todo_list_app_todo_itemsUpdateManyMutationInput, todo_list_app_todo_itemsUncheckedUpdateManyInput>\n    /**\n     * Filter which todo_list_app_todo_items to update\n     */\n    where?: todo_list_app_todo_itemsWhereInput\n    /**\n     * Limit how many todo_list_app_todo_items to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * todo_list_app_todo_items upsert\n   */\n  export type todo_list_app_todo_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * The filter to search for the todo_list_app_todo_items to update in case it exists.\n     */\n    where: todo_list_app_todo_itemsWhereUniqueInput\n    /**\n     * In case the todo_list_app_todo_items found by the `where` argument doesn't exist, create a new todo_list_app_todo_items with this data.\n     */\n    create: XOR<todo_list_app_todo_itemsCreateInput, todo_list_app_todo_itemsUncheckedCreateInput>\n    /**\n     * In case the todo_list_app_todo_items was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<todo_list_app_todo_itemsUpdateInput, todo_list_app_todo_itemsUncheckedUpdateInput>\n  }\n\n  /**\n   * todo_list_app_todo_items delete\n   */\n  export type todo_list_app_todo_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n    /**\n     * Filter which todo_list_app_todo_items to delete.\n     */\n    where: todo_list_app_todo_itemsWhereUniqueInput\n  }\n\n  /**\n   * todo_list_app_todo_items deleteMany\n   */\n  export type todo_list_app_todo_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which todo_list_app_todo_items to delete\n     */\n    where?: todo_list_app_todo_itemsWhereInput\n    /**\n     * Limit how many todo_list_app_todo_items to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * todo_list_app_todo_items without action\n   */\n  export type todo_list_app_todo_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the todo_list_app_todo_items\n     */\n    select?: todo_list_app_todo_itemsSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the todo_list_app_todo_items\n     */\n    omit?: todo_list_app_todo_itemsOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: todo_list_app_todo_itemsInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const Todo_list_app_usersScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    password_hash: 'password_hash',\n    email_verified: 'email_verified',\n    created_at: 'created_at',\n    updated_at: 'updated_at',\n    deleted_at: 'deleted_at'\n  };\n\n  export type Todo_list_app_usersScalarFieldEnum = (typeof Todo_list_app_usersScalarFieldEnum)[keyof typeof Todo_list_app_usersScalarFieldEnum]\n\n\n  export const Todo_list_app_todo_itemsScalarFieldEnum: {\n    id: 'id',\n    todo_list_app_user_id: 'todo_list_app_user_id',\n    description: 'description',\n    status: 'status',\n    created_at: 'created_at',\n    updated_at: 'updated_at'\n  };\n\n  export type Todo_list_app_todo_itemsScalarFieldEnum = (typeof Todo_list_app_todo_itemsScalarFieldEnum)[keyof typeof Todo_list_app_todo_itemsScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Boolean'\n   */\n  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type todo_list_app_usersWhereInput = {\n    AND?: todo_list_app_usersWhereInput | todo_list_app_usersWhereInput[]\n    OR?: todo_list_app_usersWhereInput[]\n    NOT?: todo_list_app_usersWhereInput | todo_list_app_usersWhereInput[]\n    id?: UuidFilter<\"todo_list_app_users\"> | string\n    email?: StringFilter<\"todo_list_app_users\"> | string\n    password_hash?: StringFilter<\"todo_list_app_users\"> | string\n    email_verified?: BoolFilter<\"todo_list_app_users\"> | boolean\n    created_at?: DateTimeFilter<\"todo_list_app_users\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_app_users\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_list_app_users\"> | Date | string | null\n    todo_list_app_todo_items?: Todo_list_app_todo_itemsListRelationFilter\n  }\n\n  export type todo_list_app_usersOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    email_verified?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    todo_list_app_todo_items?: todo_list_app_todo_itemsOrderByRelationAggregateInput\n  }\n\n  export type todo_list_app_usersWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: todo_list_app_usersWhereInput | todo_list_app_usersWhereInput[]\n    OR?: todo_list_app_usersWhereInput[]\n    NOT?: todo_list_app_usersWhereInput | todo_list_app_usersWhereInput[]\n    password_hash?: StringFilter<\"todo_list_app_users\"> | string\n    email_verified?: BoolFilter<\"todo_list_app_users\"> | boolean\n    created_at?: DateTimeFilter<\"todo_list_app_users\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_app_users\"> | Date | string\n    deleted_at?: DateTimeNullableFilter<\"todo_list_app_users\"> | Date | string | null\n    todo_list_app_todo_items?: Todo_list_app_todo_itemsListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type todo_list_app_usersOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    email_verified?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrderInput | SortOrder\n    _count?: todo_list_app_usersCountOrderByAggregateInput\n    _max?: todo_list_app_usersMaxOrderByAggregateInput\n    _min?: todo_list_app_usersMinOrderByAggregateInput\n  }\n\n  export type todo_list_app_usersScalarWhereWithAggregatesInput = {\n    AND?: todo_list_app_usersScalarWhereWithAggregatesInput | todo_list_app_usersScalarWhereWithAggregatesInput[]\n    OR?: todo_list_app_usersScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_app_usersScalarWhereWithAggregatesInput | todo_list_app_usersScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_app_users\"> | string\n    email?: StringWithAggregatesFilter<\"todo_list_app_users\"> | string\n    password_hash?: StringWithAggregatesFilter<\"todo_list_app_users\"> | string\n    email_verified?: BoolWithAggregatesFilter<\"todo_list_app_users\"> | boolean\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_app_users\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_app_users\"> | Date | string\n    deleted_at?: DateTimeNullableWithAggregatesFilter<\"todo_list_app_users\"> | Date | string | null\n  }\n\n  export type todo_list_app_todo_itemsWhereInput = {\n    AND?: todo_list_app_todo_itemsWhereInput | todo_list_app_todo_itemsWhereInput[]\n    OR?: todo_list_app_todo_itemsWhereInput[]\n    NOT?: todo_list_app_todo_itemsWhereInput | todo_list_app_todo_itemsWhereInput[]\n    id?: UuidFilter<\"todo_list_app_todo_items\"> | string\n    todo_list_app_user_id?: UuidFilter<\"todo_list_app_todo_items\"> | string\n    description?: StringFilter<\"todo_list_app_todo_items\"> | string\n    status?: StringFilter<\"todo_list_app_todo_items\"> | string\n    created_at?: DateTimeFilter<\"todo_list_app_todo_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_app_todo_items\"> | Date | string\n    user?: XOR<Todo_list_app_usersScalarRelationFilter, todo_list_app_usersWhereInput>\n  }\n\n  export type todo_list_app_todo_itemsOrderByWithRelationInput = {\n    id?: SortOrder\n    todo_list_app_user_id?: SortOrder\n    description?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    user?: todo_list_app_usersOrderByWithRelationInput\n  }\n\n  export type todo_list_app_todo_itemsWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: todo_list_app_todo_itemsWhereInput | todo_list_app_todo_itemsWhereInput[]\n    OR?: todo_list_app_todo_itemsWhereInput[]\n    NOT?: todo_list_app_todo_itemsWhereInput | todo_list_app_todo_itemsWhereInput[]\n    todo_list_app_user_id?: UuidFilter<\"todo_list_app_todo_items\"> | string\n    description?: StringFilter<\"todo_list_app_todo_items\"> | string\n    status?: StringFilter<\"todo_list_app_todo_items\"> | string\n    created_at?: DateTimeFilter<\"todo_list_app_todo_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_app_todo_items\"> | Date | string\n    user?: XOR<Todo_list_app_usersScalarRelationFilter, todo_list_app_usersWhereInput>\n  }, \"id\">\n\n  export type todo_list_app_todo_itemsOrderByWithAggregationInput = {\n    id?: SortOrder\n    todo_list_app_user_id?: SortOrder\n    description?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    _count?: todo_list_app_todo_itemsCountOrderByAggregateInput\n    _max?: todo_list_app_todo_itemsMaxOrderByAggregateInput\n    _min?: todo_list_app_todo_itemsMinOrderByAggregateInput\n  }\n\n  export type todo_list_app_todo_itemsScalarWhereWithAggregatesInput = {\n    AND?: todo_list_app_todo_itemsScalarWhereWithAggregatesInput | todo_list_app_todo_itemsScalarWhereWithAggregatesInput[]\n    OR?: todo_list_app_todo_itemsScalarWhereWithAggregatesInput[]\n    NOT?: todo_list_app_todo_itemsScalarWhereWithAggregatesInput | todo_list_app_todo_itemsScalarWhereWithAggregatesInput[]\n    id?: UuidWithAggregatesFilter<\"todo_list_app_todo_items\"> | string\n    todo_list_app_user_id?: UuidWithAggregatesFilter<\"todo_list_app_todo_items\"> | string\n    description?: StringWithAggregatesFilter<\"todo_list_app_todo_items\"> | string\n    status?: StringWithAggregatesFilter<\"todo_list_app_todo_items\"> | string\n    created_at?: DateTimeWithAggregatesFilter<\"todo_list_app_todo_items\"> | Date | string\n    updated_at?: DateTimeWithAggregatesFilter<\"todo_list_app_todo_items\"> | Date | string\n  }\n\n  export type todo_list_app_usersCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    email_verified: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_app_todo_items?: todo_list_app_todo_itemsCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_app_usersUncheckedCreateInput = {\n    id: string\n    email: string\n    password_hash: string\n    email_verified: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n    todo_list_app_todo_items?: todo_list_app_todo_itemsUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type todo_list_app_usersUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    email_verified?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_app_todo_items?: todo_list_app_todo_itemsUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_app_usersUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    email_verified?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    todo_list_app_todo_items?: todo_list_app_todo_itemsUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type todo_list_app_usersCreateManyInput = {\n    id: string\n    email: string\n    password_hash: string\n    email_verified: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_app_usersUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    email_verified?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_app_usersUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    email_verified?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_app_todo_itemsCreateInput = {\n    id: string\n    description: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n    user: todo_list_app_usersCreateNestedOneWithoutTodo_list_app_todo_itemsInput\n  }\n\n  export type todo_list_app_todo_itemsUncheckedCreateInput = {\n    id: string\n    todo_list_app_user_id: string\n    description: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_app_todo_itemsUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: todo_list_app_usersUpdateOneRequiredWithoutTodo_list_app_todo_itemsNestedInput\n  }\n\n  export type todo_list_app_todo_itemsUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_app_user_id?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_app_todo_itemsCreateManyInput = {\n    id: string\n    todo_list_app_user_id: string\n    description: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_app_todo_itemsUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_app_todo_itemsUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    todo_list_app_user_id?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type BoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type Todo_list_app_todo_itemsListRelationFilter = {\n    every?: todo_list_app_todo_itemsWhereInput\n    some?: todo_list_app_todo_itemsWhereInput\n    none?: todo_list_app_todo_itemsWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type todo_list_app_todo_itemsOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type todo_list_app_usersCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    email_verified?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_list_app_usersMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    email_verified?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type todo_list_app_usersMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    password_hash?: SortOrder\n    email_verified?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n    deleted_at?: SortOrder\n  }\n\n  export type UuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type BoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type Todo_list_app_usersScalarRelationFilter = {\n    is?: todo_list_app_usersWhereInput\n    isNot?: todo_list_app_usersWhereInput\n  }\n\n  export type todo_list_app_todo_itemsCountOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_app_user_id?: SortOrder\n    description?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_app_todo_itemsMaxOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_app_user_id?: SortOrder\n    description?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_app_todo_itemsMinOrderByAggregateInput = {\n    id?: SortOrder\n    todo_list_app_user_id?: SortOrder\n    description?: SortOrder\n    status?: SortOrder\n    created_at?: SortOrder\n    updated_at?: SortOrder\n  }\n\n  export type todo_list_app_todo_itemsCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_app_todo_itemsCreateWithoutUserInput, todo_list_app_todo_itemsUncheckedCreateWithoutUserInput> | todo_list_app_todo_itemsCreateWithoutUserInput[] | todo_list_app_todo_itemsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_app_todo_itemsCreateOrConnectWithoutUserInput | todo_list_app_todo_itemsCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_app_todo_itemsCreateManyUserInputEnvelope\n    connect?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n  }\n\n  export type todo_list_app_todo_itemsUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<todo_list_app_todo_itemsCreateWithoutUserInput, todo_list_app_todo_itemsUncheckedCreateWithoutUserInput> | todo_list_app_todo_itemsCreateWithoutUserInput[] | todo_list_app_todo_itemsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_app_todo_itemsCreateOrConnectWithoutUserInput | todo_list_app_todo_itemsCreateOrConnectWithoutUserInput[]\n    createMany?: todo_list_app_todo_itemsCreateManyUserInputEnvelope\n    connect?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type BoolFieldUpdateOperationsInput = {\n    set?: boolean\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type todo_list_app_todo_itemsUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_app_todo_itemsCreateWithoutUserInput, todo_list_app_todo_itemsUncheckedCreateWithoutUserInput> | todo_list_app_todo_itemsCreateWithoutUserInput[] | todo_list_app_todo_itemsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_app_todo_itemsCreateOrConnectWithoutUserInput | todo_list_app_todo_itemsCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_app_todo_itemsUpsertWithWhereUniqueWithoutUserInput | todo_list_app_todo_itemsUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_app_todo_itemsCreateManyUserInputEnvelope\n    set?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n    disconnect?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n    delete?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n    connect?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n    update?: todo_list_app_todo_itemsUpdateWithWhereUniqueWithoutUserInput | todo_list_app_todo_itemsUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_app_todo_itemsUpdateManyWithWhereWithoutUserInput | todo_list_app_todo_itemsUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_app_todo_itemsScalarWhereInput | todo_list_app_todo_itemsScalarWhereInput[]\n  }\n\n  export type todo_list_app_todo_itemsUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<todo_list_app_todo_itemsCreateWithoutUserInput, todo_list_app_todo_itemsUncheckedCreateWithoutUserInput> | todo_list_app_todo_itemsCreateWithoutUserInput[] | todo_list_app_todo_itemsUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: todo_list_app_todo_itemsCreateOrConnectWithoutUserInput | todo_list_app_todo_itemsCreateOrConnectWithoutUserInput[]\n    upsert?: todo_list_app_todo_itemsUpsertWithWhereUniqueWithoutUserInput | todo_list_app_todo_itemsUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: todo_list_app_todo_itemsCreateManyUserInputEnvelope\n    set?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n    disconnect?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n    delete?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n    connect?: todo_list_app_todo_itemsWhereUniqueInput | todo_list_app_todo_itemsWhereUniqueInput[]\n    update?: todo_list_app_todo_itemsUpdateWithWhereUniqueWithoutUserInput | todo_list_app_todo_itemsUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: todo_list_app_todo_itemsUpdateManyWithWhereWithoutUserInput | todo_list_app_todo_itemsUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: todo_list_app_todo_itemsScalarWhereInput | todo_list_app_todo_itemsScalarWhereInput[]\n  }\n\n  export type todo_list_app_usersCreateNestedOneWithoutTodo_list_app_todo_itemsInput = {\n    create?: XOR<todo_list_app_usersCreateWithoutTodo_list_app_todo_itemsInput, todo_list_app_usersUncheckedCreateWithoutTodo_list_app_todo_itemsInput>\n    connectOrCreate?: todo_list_app_usersCreateOrConnectWithoutTodo_list_app_todo_itemsInput\n    connect?: todo_list_app_usersWhereUniqueInput\n  }\n\n  export type todo_list_app_usersUpdateOneRequiredWithoutTodo_list_app_todo_itemsNestedInput = {\n    create?: XOR<todo_list_app_usersCreateWithoutTodo_list_app_todo_itemsInput, todo_list_app_usersUncheckedCreateWithoutTodo_list_app_todo_itemsInput>\n    connectOrCreate?: todo_list_app_usersCreateOrConnectWithoutTodo_list_app_todo_itemsInput\n    upsert?: todo_list_app_usersUpsertWithoutTodo_list_app_todo_itemsInput\n    connect?: todo_list_app_usersWhereUniqueInput\n    update?: XOR<XOR<todo_list_app_usersUpdateToOneWithWhereWithoutTodo_list_app_todo_itemsInput, todo_list_app_usersUpdateWithoutTodo_list_app_todo_itemsInput>, todo_list_app_usersUncheckedUpdateWithoutTodo_list_app_todo_itemsInput>\n  }\n\n  export type NestedUuidFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedBoolFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolFilter<$PrismaModel> | boolean\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: boolean | BooleanFieldRefInput<$PrismaModel>\n    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedBoolFilter<$PrismaModel>\n    _max?: NestedBoolFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type todo_list_app_todo_itemsCreateWithoutUserInput = {\n    id: string\n    description: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_app_todo_itemsUncheckedCreateWithoutUserInput = {\n    id: string\n    description: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_app_todo_itemsCreateOrConnectWithoutUserInput = {\n    where: todo_list_app_todo_itemsWhereUniqueInput\n    create: XOR<todo_list_app_todo_itemsCreateWithoutUserInput, todo_list_app_todo_itemsUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_app_todo_itemsCreateManyUserInputEnvelope = {\n    data: todo_list_app_todo_itemsCreateManyUserInput | todo_list_app_todo_itemsCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type todo_list_app_todo_itemsUpsertWithWhereUniqueWithoutUserInput = {\n    where: todo_list_app_todo_itemsWhereUniqueInput\n    update: XOR<todo_list_app_todo_itemsUpdateWithoutUserInput, todo_list_app_todo_itemsUncheckedUpdateWithoutUserInput>\n    create: XOR<todo_list_app_todo_itemsCreateWithoutUserInput, todo_list_app_todo_itemsUncheckedCreateWithoutUserInput>\n  }\n\n  export type todo_list_app_todo_itemsUpdateWithWhereUniqueWithoutUserInput = {\n    where: todo_list_app_todo_itemsWhereUniqueInput\n    data: XOR<todo_list_app_todo_itemsUpdateWithoutUserInput, todo_list_app_todo_itemsUncheckedUpdateWithoutUserInput>\n  }\n\n  export type todo_list_app_todo_itemsUpdateManyWithWhereWithoutUserInput = {\n    where: todo_list_app_todo_itemsScalarWhereInput\n    data: XOR<todo_list_app_todo_itemsUpdateManyMutationInput, todo_list_app_todo_itemsUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type todo_list_app_todo_itemsScalarWhereInput = {\n    AND?: todo_list_app_todo_itemsScalarWhereInput | todo_list_app_todo_itemsScalarWhereInput[]\n    OR?: todo_list_app_todo_itemsScalarWhereInput[]\n    NOT?: todo_list_app_todo_itemsScalarWhereInput | todo_list_app_todo_itemsScalarWhereInput[]\n    id?: UuidFilter<\"todo_list_app_todo_items\"> | string\n    todo_list_app_user_id?: UuidFilter<\"todo_list_app_todo_items\"> | string\n    description?: StringFilter<\"todo_list_app_todo_items\"> | string\n    status?: StringFilter<\"todo_list_app_todo_items\"> | string\n    created_at?: DateTimeFilter<\"todo_list_app_todo_items\"> | Date | string\n    updated_at?: DateTimeFilter<\"todo_list_app_todo_items\"> | Date | string\n  }\n\n  export type todo_list_app_usersCreateWithoutTodo_list_app_todo_itemsInput = {\n    id: string\n    email: string\n    password_hash: string\n    email_verified: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_app_usersUncheckedCreateWithoutTodo_list_app_todo_itemsInput = {\n    id: string\n    email: string\n    password_hash: string\n    email_verified: boolean\n    created_at: Date | string\n    updated_at: Date | string\n    deleted_at?: Date | string | null\n  }\n\n  export type todo_list_app_usersCreateOrConnectWithoutTodo_list_app_todo_itemsInput = {\n    where: todo_list_app_usersWhereUniqueInput\n    create: XOR<todo_list_app_usersCreateWithoutTodo_list_app_todo_itemsInput, todo_list_app_usersUncheckedCreateWithoutTodo_list_app_todo_itemsInput>\n  }\n\n  export type todo_list_app_usersUpsertWithoutTodo_list_app_todo_itemsInput = {\n    update: XOR<todo_list_app_usersUpdateWithoutTodo_list_app_todo_itemsInput, todo_list_app_usersUncheckedUpdateWithoutTodo_list_app_todo_itemsInput>\n    create: XOR<todo_list_app_usersCreateWithoutTodo_list_app_todo_itemsInput, todo_list_app_usersUncheckedCreateWithoutTodo_list_app_todo_itemsInput>\n    where?: todo_list_app_usersWhereInput\n  }\n\n  export type todo_list_app_usersUpdateToOneWithWhereWithoutTodo_list_app_todo_itemsInput = {\n    where?: todo_list_app_usersWhereInput\n    data: XOR<todo_list_app_usersUpdateWithoutTodo_list_app_todo_itemsInput, todo_list_app_usersUncheckedUpdateWithoutTodo_list_app_todo_itemsInput>\n  }\n\n  export type todo_list_app_usersUpdateWithoutTodo_list_app_todo_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    email_verified?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_app_usersUncheckedUpdateWithoutTodo_list_app_todo_itemsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    password_hash?: StringFieldUpdateOperationsInput | string\n    email_verified?: BoolFieldUpdateOperationsInput | boolean\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n  }\n\n  export type todo_list_app_todo_itemsCreateManyUserInput = {\n    id: string\n    description: string\n    status: string\n    created_at: Date | string\n    updated_at: Date | string\n  }\n\n  export type todo_list_app_todo_itemsUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_app_todo_itemsUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type todo_list_app_todo_itemsUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    description?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    created_at?: DateTimeFieldUpdateOperationsInput | Date | string\n    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","node_modules/.prisma/client/runtime/client.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/index-browser.d.ts":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/runtime/library.d.ts":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\n/**\r\n * A stripped down interface of `fetch` that `@prisma/extension-accelerate`\r\n * relies on. It must be in sync with the corresponding definition in the\r\n * Accelerate extension.\r\n *\r\n * This is the actual interface exposed by the extension. We can't use the\r\n * custom fetch function provided by it as normal fetch because the API is\r\n * different. Notably, `headers` must be an object and not a `Headers`\r\n * instance, and `url` must be a `string` and not a `URL`.\r\n *\r\n * The return type is `Response` but we can't specify this in an exported type\r\n * because it would end up referencing external types from `@types/node` or DOM\r\n * which can fail typechecking depending on TypeScript configuration in a user's\r\n * project.\r\n */\r\ndeclare type AccelerateExtensionFetch = (url: string, options: {\r\n    body?: string;\r\n    method?: string;\r\n    headers: Record<string, string>;\r\n}) => Promise<unknown>;\r\n\r\ndeclare type AccelerateExtensionFetchDecorator = (fetch: AccelerateExtensionFetch) => AccelerateExtensionFetch;\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\ndeclare type ArgScalarType = 'string' | 'int' | 'bigint' | 'float' | 'decimal' | 'boolean' | 'enum' | 'uuid' | 'json' | 'datetime' | 'bytes' | 'unknown';\r\n\r\ndeclare type ArgType = {\r\n    scalarType: ArgScalarType;\r\n    dbType?: string;\r\n    arity: Arity;\r\n};\r\n\r\ndeclare type Arity = 'scalar' | 'list';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: QueryPlanNode;\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type DataRule = {\r\n    type: 'rowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'rowCountNeq';\r\n    args: number;\r\n} | {\r\n    type: 'affectedRowCountEq';\r\n    args: number;\r\n} | {\r\n    type: 'never';\r\n};\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\ndeclare type DynamicArgType = ArgType | {\r\n    arity: 'tuple';\r\n    elements: ArgType[];\r\n};\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = MappedError & {\r\n    originalCode?: string;\r\n    originalMessage?: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldInitializer = {\r\n    type: 'value';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'lastInsertId';\r\n};\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\ndeclare type FieldOperation = {\r\n    type: 'set';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'add';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'subtract';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'multiply';\r\n    value: PrismaValue;\r\n} | {\r\n    type: 'divide';\r\n    value: PrismaValue;\r\n};\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FieldScalarType = {\r\n    type: 'string' | 'int' | 'bigint' | 'float' | 'boolean' | 'json' | 'object' | 'datetime' | 'decimal' | 'unsupported';\r\n} | {\r\n    type: 'enum';\r\n    name: string;\r\n} | {\r\n    type: 'bytes';\r\n    encoding: 'array' | 'base64' | 'hex';\r\n};\r\n\r\ndeclare type FieldType = {\r\n    arity: Arity;\r\n} & FieldScalarType;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare type Fragment = {\r\n    type: 'stringChunk';\r\n    chunk: string;\r\n} | {\r\n    type: 'parameter';\r\n} | {\r\n    type: 'parameterTuple';\r\n} | {\r\n    type: 'parameterTupleList';\r\n    itemPrefix: string;\r\n    itemSeparator: string;\r\n    itemSuffix: string;\r\n    groupSeparator: string;\r\n};\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\ndeclare type InMemoryOps = {\r\n    pagination: Pagination | null;\r\n    distinct: string[] | null;\r\n    reverse: boolean;\r\n    linkingFields: string[] | null;\r\n    nested: Record<string, InMemoryOps>;\r\n};\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\ndeclare type JoinExpression = {\r\n    child: QueryPlanNode;\r\n    on: [left: string, right: string][];\r\n    parentField: string;\r\n    isRelationUnique: boolean;\r\n};\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type MappedError = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseNotReachable';\r\n    host?: string;\r\n    port?: number;\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'ConnectionClosed';\r\n} | {\r\n    kind: 'TlsConnectionError';\r\n    reason: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: QueryPlanNode[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\ndeclare type Pagination = {\r\n    cursor: Record<string, PrismaValue> | null;\r\n    take: number | null;\r\n    skip: number | null;\r\n};\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare interface PlaceholderFormat {\r\n    prefix: string;\r\n    hasNumbering: boolean;\r\n}\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\ndeclare type PrismaValue = string | boolean | number | PrismaValue[] | null | Record<string, unknown> | PrismaValuePlaceholder | PrismaValueGenerator;\r\n\r\ndeclare type PrismaValueGenerator = {\r\n    prisma__type: 'generatorCall';\r\n    prisma__value: {\r\n        name: string;\r\n        args: PrismaValue[];\r\n    };\r\n};\r\n\r\ndeclare type PrismaValuePlaceholder = {\r\n    prisma__type: 'param';\r\n    prisma__value: {\r\n        name: string;\r\n        type: string;\r\n    };\r\n};\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: Object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\ndeclare type QueryPlanBinding = {\r\n    name: string;\r\n    expr: QueryPlanNode;\r\n};\r\n\r\ndeclare type QueryPlanDbQuery = {\r\n    type: 'rawSql';\r\n    sql: string;\r\n    args: PrismaValue[];\r\n    argTypes: ArgType[];\r\n} | {\r\n    type: 'templateSql';\r\n    fragments: Fragment[];\r\n    placeholderFormat: PlaceholderFormat;\r\n    args: PrismaValue[];\r\n    argTypes: DynamicArgType[];\r\n    chunkable: boolean;\r\n};\r\n\r\ndeclare type QueryPlanNode = {\r\n    type: 'value';\r\n    args: PrismaValue;\r\n} | {\r\n    type: 'seq';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'get';\r\n    args: {\r\n        name: string;\r\n    };\r\n} | {\r\n    type: 'let';\r\n    args: {\r\n        bindings: QueryPlanBinding[];\r\n        expr: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'getFirstNonEmpty';\r\n    args: {\r\n        names: string[];\r\n    };\r\n} | {\r\n    type: 'query';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'execute';\r\n    args: QueryPlanDbQuery;\r\n} | {\r\n    type: 'reverse';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'sum';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'concat';\r\n    args: QueryPlanNode[];\r\n} | {\r\n    type: 'unique';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'required';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'join';\r\n    args: {\r\n        parent: QueryPlanNode;\r\n        children: JoinExpression[];\r\n    };\r\n} | {\r\n    type: 'mapField';\r\n    args: {\r\n        field: string;\r\n        records: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'transaction';\r\n    args: QueryPlanNode;\r\n} | {\r\n    type: 'dataMap';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        structure: ResultNode;\r\n        enums: Record<string, Record<string, string>>;\r\n    };\r\n} | {\r\n    type: 'validate';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        rules: DataRule[];\r\n    } & ValidationError;\r\n} | {\r\n    type: 'if';\r\n    args: {\r\n        value: QueryPlanNode;\r\n        rule: DataRule;\r\n        then: QueryPlanNode;\r\n        else: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'unit';\r\n} | {\r\n    type: 'diff';\r\n    args: {\r\n        from: QueryPlanNode;\r\n        to: QueryPlanNode;\r\n    };\r\n} | {\r\n    type: 'initializeRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldInitializer>;\r\n    };\r\n} | {\r\n    type: 'mapRecord';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        fields: Record<string, FieldOperation>;\r\n    };\r\n} | {\r\n    type: 'process';\r\n    args: {\r\n        expr: QueryPlanNode;\r\n        operations: InMemoryOps;\r\n    };\r\n};\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: AccelerateExtensionFetchDecorator;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ResultNode = {\r\n    type: 'affectedRows';\r\n} | {\r\n    type: 'object';\r\n    fields: Record<string, ResultNode>;\r\n    serializedName: string | null;\r\n    skipNulls: boolean;\r\n} | {\r\n    type: 'field';\r\n    dbName: string;\r\n    fieldType: FieldType;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma?: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    requiresOtherFields?: string[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare type ValidationError = {\r\n    error_identifier: 'RELATION_VIOLATION';\r\n    context: {\r\n        relation: string;\r\n        modelA: string;\r\n        modelB: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RELATED_RECORD';\r\n    context: {\r\n        model: string;\r\n        relation: string;\r\n        relationType: string;\r\n        operation: string;\r\n        neededFor?: string;\r\n    };\r\n} | {\r\n    error_identifier: 'MISSING_RECORD';\r\n    context: {\r\n        operation: string;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_INPUT';\r\n    context: {\r\n        expectedRows: number;\r\n    };\r\n} | {\r\n    error_identifier: 'INCOMPLETE_CONNECT_OUTPUT';\r\n    context: {\r\n        expectedRows: number;\r\n        relation: string;\r\n        relationType: string;\r\n    };\r\n} | {\r\n    error_identifier: 'RECORDS_NOT_CONNECTED';\r\n    context: {\r\n        relation: string;\r\n        parent: string;\r\n        child: string;\r\n    };\r\n};\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","node_modules/.prisma/client/wasm.d.ts":"export * from \"./default\"","node_modules/@prisma/client/index.d.ts":"export * from '.prisma/client/default'"},"document":"# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Actors](#actors)\n- [Todo](#todo)\n\n## Actors\n\n```mermaid\nerDiagram\n\"todo_list_app_users\" {\n  String id PK\n  String email UK\n  String password_hash\n  Boolean email_verified\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n```\n\n### `todo_list_app_users`\n\nUser accounts for the Todo List Application, storing authentication data\nincluding email, password hash, email verification status, and\ntimestamps. This entity represents individual users who own todo items.\nThe table supports soft deletion for account recovery and provides audit\nfields for tracking creation and modification times. Email is unique\nallowing identification and login. Relates to todo_list_app_todo_items\nfor ownership of tasks.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `email`: User's unique email address used for login and identity verification.\n- `password_hash`: Hashed password for user authentication, never store plain text passwords.\n- `email_verified`: Flag indicating whether the user's email address has been verified.\n- `created_at`: Timestamp when the user account was created.\n- `updated_at`: Timestamp when the user account was last updated.\n- `deleted_at`\n  > Timestamp indicating when the user account was soft deleted, if\n  > applicable.\n\n## Todo\n\n```mermaid\nerDiagram\n\"todo_list_app_todo_items\" {\n  String id PK\n  String todo_list_app_user_id FK\n  String description\n  String status\n  DateTime created_at\n  DateTime updated_at\n}\n```\n\n### `todo_list_app_todo_items`\n\nRepresents individual todo items created and managed by users in the todo\nlist application. Each item is tied exclusively to one user, with a\nstatus indicating completion state and timestamps for creation and last\nupdate. This model enables users to independently create, view, update,\nand delete their tasks while enforcing ownership and access control. It\nreferences the users table for ownership association.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `todo_list_app_user_id`: Owning user's [todo_list_app_users.id](#todo_list_app_users).\n- `description`\n  > Task description text. Non-empty string up to 256 characters, validated\n  > by application logic.\n- `status`: Task completion status, only 'pending' or 'done' values allowed.\n- `created_at`: Timestamp when the todo item was created.\n- `updated_at`: Timestamp when the todo item was last updated.\n","diagrams":{"Actors":"```mermaid\nerDiagram\n\"todo_list_app_users\" {\n  String id PK\n  String email UK\n  String password_hash\n  Boolean email_verified\n  DateTime created_at\n  DateTime updated_at\n  DateTime deleted_at \"nullable\"\n}\n```","Todo":"```mermaid\nerDiagram\n\"todo_list_app_todo_items\" {\n  String id PK\n  String todo_list_app_user_id FK\n  String description\n  String status\n  DateTime created_at\n  DateTime updated_at\n}\n```"}},"created_at":"2025-09-30T15:14:15.936Z","completed_at":"2025-09-30T15:15:35.566Z","step":0},{"id":"01999b31-7c73-71b8-a023-56b3e8ff7461","type":"userMessage","contents":[{"type":"text","text":"Create the API interface specification."}],"created_at":"2025-09-30T15:15:35.667Z"},{"type":"interface","id":"01999b3d-a559-74df-9686-3a0d9cd9e742","instruction":"Design API interfaces for a minimal Todo list application with the following features: single user, ability to add new tasks, mark tasks as done, delete tasks, and retrieve the list of tasks. Endpoints should support CRUD operations on Todo tasks. Requests and responses should include task identifier, description, completion status, and timestamps where applicable. Focus on simple, clear RESTful patterns with minimal complexity.","authorizations":[{"role":"user","operations":[{"specification":"This API operation handles user registration (joining) for the 'user' role in the todoListApp system. It creates a new user account with email and password, ensuring the user is stored in the todo_list_app_users table. The required fields for creation are email, password_hash, email_verified (initially false), and timestamps for created_at and updated_at. The operation returns authorized user info with JWT tokens as per authentication standards. The operation is public (no authentication required), allowing new users to sign up. It enforces password policies and unique email addresses as per business rules. This endpoint uses the 'join' authorization type and corresponds to the 'todo_list_app_users' table representing user accounts. The operation schema maps to ITodoListAppUser.ICreate request body and returns an ITodoListAppUser.IAuthorized response body containing authorized user info with tokens. Recommended path is '/auth/user/join', method POST, matching RESTful conventions.\n\n-- Detailed Description --\nThe 'join' operation allows a new user to register an account with their email and password. The Prisma schema todo_list_app_users includes fields to support email verification (email_verified), password hashing (password_hash), and soft deletion (deleted_at). This operation requires creating a new entry with email, password_hash and sets email_verified to false initially. The system tracks creation and update timestamps. Email uniqueness and password strength are enforced as project policies outside this API spec but should be validated before calling this endpoint. On successful registration, the operation returns authorization tokens encapsulated in ITodoListAppUser.IAuthorized, enabling immediate authenticated interaction with the todo list app.\n\nBecause the user is of kind 'member', the operation also supports login and token refresh endpoints as essential auth operations.\n\nSecurity considerations ensure the password is never stored or returned in plain text; only hashed passwords are accepted and stored. The operation clearly separates registration from login, enhancing security and user management.\n\nLogin and refresh operations complement this join endpoint in a full authentication flow.","authorizationType":"join","description":"Registers a new user account for the 'user' role in the todoListApp backend. Validates email and password, stores user with hashed password and unverified email status. On success, issues JWT access and refresh tokens. This operation targets the todo_list_app_users table representing user accounts. It manages creation timestamps and enforces email uniqueness. This endpoint uses the 'join' authorization type indicating user registration. Validation of email format and password policies are enforced at the application layer before calling. Returns an authorized user response type ITodoListAppUser.IAuthorized.","summary":"Register new user for todo_list_app_users table","parameters":[],"requestBody":{"description":"User registration data including email and password, encapsulated in ITodoListAppUser.ICreate.","typeName":"ITodoListAppUser.ICreate"},"responseBody":{"description":"Authorized user data with JWT tokens after successful registration.","typeName":"ITodoListAppUser.IAuthorized"},"authorizationRole":"user","name":"join","prerequisites":[],"path":"/auth/user/join","method":"post"},{"specification":"This API operation handles user login for the 'user' role in the todoListApp system, authenticating a user by verifying the email and password against stored credentials in the todo_list_app_users table. It returns JWT access and refresh tokens encapsulated in the ITodoListAppUser.IAuthorized response type. The operation is public and uses the 'login' authorization type. The endpoint follows RESTful conventions with path '/auth/user/login' and method POST.\n\n-- Detailed Description --\nLogin verifies the user's credentials by checking the email against a unique email field in the todo_list_app_users table and validating the provided password against the stored password_hash. The user must have a verified email (email_verified=true) and no deleted_at timestamp to be allowed to login. If these conditions are met and the password matches, JWT tokens are issued for session management.\n\nSecurity considerations ensure no plain text password is stored or returned, and proper error handling is implemented to prevent credential leakage. This operation is essential for the 'member' kind user role as it provides authentication. It complements the join and refresh endpoints.\n\nThe response uses ITodoListAppUser.IAuthorized to return tokens for secure communication.\n\nThis operation relies on the todo_list_app_users Prisma schema model supporting email, password_hash, email_verified, and deleted_at columns for secure and managed authentication state.","authorizationType":"login","description":"Authenticates an existing user by verifying email and password for the 'user' role in todoListApp. Validates credentials against stored password hash and email verification status. Issues JWT access and refresh tokens upon successful login. Relies on todo_list_app_users table with unique email and password_hash fields. Ensures user is not soft deleted and has verified email. Uses 'login' authorization type as a secure authentication entry point. Returns authorized user response ITodoListAppUser.IAuthorized.","summary":"User login for todo_list_app_users table","parameters":[],"requestBody":{"description":"Login credentials including email and password, defined in ITodoListAppUser.ILogin.","typeName":"ITodoListAppUser.ILogin"},"responseBody":{"description":"Authorized user data with JWT tokens after successful login.","typeName":"ITodoListAppUser.IAuthorized"},"authorizationRole":"user","name":"login","prerequisites":[],"path":"/auth/user/login","method":"post"},{"specification":"This API operation refreshes the access token for the 'user' role in todoListApp by accepting a valid refresh token and returning a new access token encapsulated in ITodoListAppUser.IAuthorized. It ensures continual access without requiring re-login. The endpoint is accessible with authorization type 'refresh' and is located at '/auth/user/refresh' with POST method.\n\n-- Detailed Description --\nRefresh token operation requires a valid refresh token issued at login or registration. It checks the token's validity and user existence in the todo_list_app_users table with non-null email, verified email state, and no deletion timestamp. Upon success, new JWT tokens are issued to maintain session continuity.\n\nSecurity is critical; refresh tokens must be securely stored and transmitted over HTTPS. This operation forms an essential part of the authentication lifecycle for 'member' kind users, working alongside 'join' and 'login' endpoints.\n\nResponse type ITodoListAppUser.IAuthorized encapsulates the updated authorized state with tokens.\n\nThe Prisma schema todo_list_app_users supports these flows via its fields email, email_verified, and deleted_at to manage account states accordingly.","authorizationType":"refresh","description":"Refreshes JWT access token for the 'user' role using a valid refresh token. Ensures continuous authenticated session without user re-login. Relies on the todo_list_app_users table to validate user existence, email verification status, and account state. Uses 'refresh' authorization type indicating token renewal. Returns authorized user response ITodoListAppUser.IAuthorized with new tokens.","summary":"Refresh JWT token for todo_list_app_users table","parameters":[],"requestBody":{"description":"Refresh token request data containing the refresh token, defined in ITodoListAppUser.IRefresh.","typeName":"ITodoListAppUser.IRefresh"},"responseBody":{"description":"Authorized user data with fresh JWT tokens after refresh.","typeName":"ITodoListAppUser.IAuthorized"},"authorizationRole":"user","name":"refresh","prerequisites":[],"path":"/auth/user/refresh","method":"post"}]}],"document":{"operations":[{"specification":"This API operation handles user registration (joining) for the 'user' role in the todoListApp system. It creates a new user account with email and password, ensuring the user is stored in the todo_list_app_users table. The required fields for creation are email, password_hash, email_verified (initially false), and timestamps for created_at and updated_at. The operation returns authorized user info with JWT tokens as per authentication standards. The operation is public (no authentication required), allowing new users to sign up. It enforces password policies and unique email addresses as per business rules. This endpoint uses the 'join' authorization type and corresponds to the 'todo_list_app_users' table representing user accounts. The operation schema maps to ITodoListAppUser.ICreate request body and returns an ITodoListAppUser.IAuthorized response body containing authorized user info with tokens. Recommended path is '/auth/user/join', method POST, matching RESTful conventions.\n\n-- Detailed Description --\nThe 'join' operation allows a new user to register an account with their email and password. The Prisma schema todo_list_app_users includes fields to support email verification (email_verified), password hashing (password_hash), and soft deletion (deleted_at). This operation requires creating a new entry with email, password_hash and sets email_verified to false initially. The system tracks creation and update timestamps. Email uniqueness and password strength are enforced as project policies outside this API spec but should be validated before calling this endpoint. On successful registration, the operation returns authorization tokens encapsulated in ITodoListAppUser.IAuthorized, enabling immediate authenticated interaction with the todo list app.\n\nBecause the user is of kind 'member', the operation also supports login and token refresh endpoints as essential auth operations.\n\nSecurity considerations ensure the password is never stored or returned in plain text; only hashed passwords are accepted and stored. The operation clearly separates registration from login, enhancing security and user management.\n\nLogin and refresh operations complement this join endpoint in a full authentication flow.","authorizationType":"join","description":"Registers a new user account for the 'user' role in the todoListApp backend. Validates email and password, stores user with hashed password and unverified email status. On success, issues JWT access and refresh tokens. This operation targets the todo_list_app_users table representing user accounts. It manages creation timestamps and enforces email uniqueness. This endpoint uses the 'join' authorization type indicating user registration. Validation of email format and password policies are enforced at the application layer before calling. Returns an authorized user response type ITodoListAppUser.IAuthorized.","summary":"Register new user for todo_list_app_users table","parameters":[],"requestBody":{"description":"User registration data including email and password, encapsulated in ITodoListAppUser.ICreate.","typeName":"ITodoListAppUser.ICreate"},"responseBody":{"description":"Authorized user data with JWT tokens after successful registration.","typeName":"ITodoListAppUser.IAuthorized"},"authorizationRole":"user","name":"join","prerequisites":[],"path":"/auth/user/join","method":"post"},{"specification":"This API operation handles user login for the 'user' role in the todoListApp system, authenticating a user by verifying the email and password against stored credentials in the todo_list_app_users table. It returns JWT access and refresh tokens encapsulated in the ITodoListAppUser.IAuthorized response type. The operation is public and uses the 'login' authorization type. The endpoint follows RESTful conventions with path '/auth/user/login' and method POST.\n\n-- Detailed Description --\nLogin verifies the user's credentials by checking the email against a unique email field in the todo_list_app_users table and validating the provided password against the stored password_hash. The user must have a verified email (email_verified=true) and no deleted_at timestamp to be allowed to login. If these conditions are met and the password matches, JWT tokens are issued for session management.\n\nSecurity considerations ensure no plain text password is stored or returned, and proper error handling is implemented to prevent credential leakage. This operation is essential for the 'member' kind user role as it provides authentication. It complements the join and refresh endpoints.\n\nThe response uses ITodoListAppUser.IAuthorized to return tokens for secure communication.\n\nThis operation relies on the todo_list_app_users Prisma schema model supporting email, password_hash, email_verified, and deleted_at columns for secure and managed authentication state.","authorizationType":"login","description":"Authenticates an existing user by verifying email and password for the 'user' role in todoListApp. Validates credentials against stored password hash and email verification status. Issues JWT access and refresh tokens upon successful login. Relies on todo_list_app_users table with unique email and password_hash fields. Ensures user is not soft deleted and has verified email. Uses 'login' authorization type as a secure authentication entry point. Returns authorized user response ITodoListAppUser.IAuthorized.","summary":"User login for todo_list_app_users table","parameters":[],"requestBody":{"description":"Login credentials including email and password, defined in ITodoListAppUser.ILogin.","typeName":"ITodoListAppUser.ILogin"},"responseBody":{"description":"Authorized user data with JWT tokens after successful login.","typeName":"ITodoListAppUser.IAuthorized"},"authorizationRole":"user","name":"login","prerequisites":[],"path":"/auth/user/login","method":"post"},{"specification":"This API operation refreshes the access token for the 'user' role in todoListApp by accepting a valid refresh token and returning a new access token encapsulated in ITodoListAppUser.IAuthorized. It ensures continual access without requiring re-login. The endpoint is accessible with authorization type 'refresh' and is located at '/auth/user/refresh' with POST method.\n\n-- Detailed Description --\nRefresh token operation requires a valid refresh token issued at login or registration. It checks the token's validity and user existence in the todo_list_app_users table with non-null email, verified email state, and no deletion timestamp. Upon success, new JWT tokens are issued to maintain session continuity.\n\nSecurity is critical; refresh tokens must be securely stored and transmitted over HTTPS. This operation forms an essential part of the authentication lifecycle for 'member' kind users, working alongside 'join' and 'login' endpoints.\n\nResponse type ITodoListAppUser.IAuthorized encapsulates the updated authorized state with tokens.\n\nThe Prisma schema todo_list_app_users supports these flows via its fields email, email_verified, and deleted_at to manage account states accordingly.","authorizationType":"refresh","description":"Refreshes JWT access token for the 'user' role using a valid refresh token. Ensures continuous authenticated session without user re-login. Relies on the todo_list_app_users table to validate user existence, email verification status, and account state. Uses 'refresh' authorization type indicating token renewal. Returns authorized user response ITodoListAppUser.IAuthorized with new tokens.","summary":"Refresh JWT token for todo_list_app_users table","parameters":[],"requestBody":{"description":"Refresh token request data containing the refresh token, defined in ITodoListAppUser.IRefresh.","typeName":"ITodoListAppUser.IRefresh"},"responseBody":{"description":"Authorized user data with fresh JWT tokens after refresh.","typeName":"ITodoListAppUser.IAuthorized"},"authorizationRole":"user","name":"refresh","prerequisites":[],"path":"/auth/user/refresh","method":"post"},{"specification":"This operation retrieves detailed information for an individual user in the todo_list_app_users table from the Prisma schema. It supports fetching user account data by unique user ID. The table includes fields such as id (UUID primary key), email (unique email address), email_verified (boolean flag), timestamps for creation, update, and soft deletion (nullable). The operation enforces security by allowing only authorized roles to access sensitive user data. It returns the main user entity object with the password hash field omitted for security compliance.","description":"This operation fetches detailed information about a single user account identified by their unique UUID. It retrieves the user's email, email verification status, and timestamps related to when the account was created, last updated, and deleted (if soft deleted).\n\nSecurity considerations require that only authorized roles can access this endpoint since it exposes sensitive authentication data. The password hash field is excluded to prevent exposure of sensitive information.\n\nThe operation tightly couples with the todo_list_app_users table in the Prisma schema ensuring that the exact fields and data integrity rules are respected. It returns a complete user object matching the schema properties, excluding sensitive password data.\n\nTypical errors include attempting to fetch a user ID that does not exist, which should return a not-found error. Unauthorized access attempts should be rejected with a 403 or similar error.\n\nThis operation is distinct from list or update operations and serves as a granular user data retrieval endpoint, often supporting administrative or account management UI features.","summary":"Retrieve detailed information of a specific todo list app user account","parameters":[{"name":"id","description":"Unique identifier of the todo list app user","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"The detailed user account information for the specified user ID without password hash","typeName":"ITodoListAppTodoListAppUsers.ISafe"},"authorizationRoles":["user"],"name":"at","path":"/todoListApp/user/todoListAppUsers/{id}","method":"get","authorizationRole":"user","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"description":"A todo item must be created for the user before retrieving detailed information of the user."}]},{"specification":"This operation retrieves a paginated list of todo list app user accounts matching optional search and filter criteria. It supports pagination, sorting, and filtering parameters encapsulated in the request body. The user table represents individual user accounts with fields such as id (UUID), email, email verified flag, created and updated timestamps, and nullable soft delete timestamp.\n\nThe operation supports advanced searching and sorting capabilities on user properties such as email, creation date, and verification status. Pagination controls allow clients to request specific pages and sizes.\n\nThe response returns a paginated container holding summary information of users optimized for list display.\n\nSecurity considerations require that only authorized roles can perform this search, which generally is limited to admin or similar roles managing user accounts.\n\nThis operation does not alter any data and provides a read-only list operation for user accounts.","description":"This operation enables clients to perform complex search and retrieval operations over todo list app users. The request body supports specifying search filters like email substring matching, filtering by email verification status, and sorting preferences including sort column and order.\n\nThe response is a paginated list of user summary objects optimized for UI rendering in admin or management dashboards.\n\nProper validation of input parameters in the request body ensures effective filtering and prevents injection or invalid queries.\n\nSecurity constraints mean only authorized user roles can execute this operation, limiting exposure of sensitive user data.\n\nThis endpoint complements single-entity retrieval and update endpoints providing complete user account management capabilities.","summary":"Search and retrieve a filtered, paginated list of todo list app users","parameters":[],"requestBody":{"description":"Search criteria and pagination parameters for todo list user filtering","typeName":"ITodoListAppTodoListAppUsers.IRequest"},"responseBody":{"description":"Paginated list of todo list app user summary information matching search criteria","typeName":"IPageITodoListAppTodoListAppUsers.ISummary"},"authorizationRoles":["user"],"name":"index","path":"/todoListApp/user/todoListAppUsers","method":"patch","authorizationRole":"user","authorizationType":null,"prerequisites":[]},{"specification":"This operation updates an existing user account in the todo_list_app_users table. It accepts a full update of the user properties provided in the request body, identified by the unique user ID in the path parameter.\n\nThe update respects validation rules on fields such as email uniqueness and password hash format. It allows modification of email, password_hash, email_verified status, and timestamps excluding soft deletion timestamp which is managed internally.\n\nThe operation enforces ownership and authorization ensuring only permitted roles may update user accounts. The updated record is returned in the response reflecting new values.\n\nErrors include conflict on unique email constraint or attempts to update non-existent users.\n\nThis operation integrates with the existing user management flow allowing account data alterations.","description":"Update detailed information of an existing todo list app user account. The request body must contain the updated email, password hash, email verification status, and timestamps as needed. The user account is identified by the id path parameter. Ownership and permission checks ensure only authorized modification.\n\nThis operation modifies core user identity fields and is critical for account management and security enforcement.\n\nProper validation and transactional integrity are essential to maintain data consistency and application security.","summary":"Update details of a specific todo list app user account","parameters":[{"name":"id","description":"Unique identifier of the todo list app user to update","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Updated user account information for the specified user ID","typeName":"ITodoListAppTodoListAppUsers.IUpdate"},"responseBody":{"description":"The updated user account record reflecting all changes","typeName":"ITodoListAppTodoListAppUsers"},"authorizationRoles":["user"],"name":"update","path":"/todoListApp/user/todoListAppUsers/{id}","method":"put","authorizationRole":"user","authorizationType":null,"prerequisites":[{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"description":"A todo item must be created for the user before updating the user."}]},{"specification":"This operation permanently deletes the todoListAppUsers record identified by the user's unique UUID id. It directly manipulates the todo_list_app_users table as defined in the Prisma schema, specifically the user account entity that stores authentication data such as email, password hash, email verification, and timestamps. This deletion operation removes the user account record and cascades the deletion of associated todo items due to the onDelete: Cascade relation defined in the schema. It requires the unique user id as a path parameter. No request body is required, and there is no response body. Authorization roles should include \"user\" to restrict deletion to authenticated users, presumably the owner of the account.","description":"Permanently removes the user account record specified by the {id} in the path from the database, including cascade deletion of owned todo items as per Prisma schema rules. This operation MUST verify that the requesting user is authorized to delete their own account to prevent unauthorized user removal. It operates directly on the todo_list_app_users table, which stores user authentication credentials and related metadata.\n\nSecurity considerations require strong authentication and authorization checks, as deleting a user account cannot be undone and will remove all associated task data. This endpoint is critical and must ensure only the authenticated owner can perform this deletion.\n\nExpected behavior includes validation of the {id} as a UUID, verification of user ownership, and a hard (permanent) delete operation with no recovery.\n\nNo request body is sent, and no response body is returned on successful deletion. Error handling includes responding with authorization errors for unauthorized attempts, not found errors if the user does not exist, and appropriate server error messages for unexpected failures.","summary":"Delete a todoListApp user account by id","parameters":[{"name":"id","in":"path","description":"Unique identifier of the user account to delete","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"user","name":"erase","path":"/todoListApp/user/todoListAppUsers/{id}","method":"delete","prerequisites":[{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"description":"The todo list app user must be created before the user account can be deleted."}]},{"specification":"This operation retrieves a paginated list of todo list tasks owned by a specific user, enabling filtering, sorting, and searching capabilities. It operates directly on the todo_list_app_todo_items table related to the todo_list_app_users table via the todo_list_app_user_id foreign key. Parameters include the user ID to scope the tasks to that user.\n\nThe request body expects an object containing search criteria, pagination options, and sorting preferences for todo items. The response returns a paginated, searchable list of todo items including identifiers, descriptions, statuses, and timestamps. This supports the user's need to view and manage their tasks effectively.\n\nAuthorization requires the user role, ensuring only authenticated users can access their tasks. The operation name is \"index\" following REST conventions for listing resources.","description":"Retrieve a filtered and paginated list of todo items owned by the user identified by {todoListAppUserId}. This supports searching, sorting, and paging to optimize task management.\n\nThis operation enforces ownership, meaning users can only retrieve their own tasks. It interacts with the todo_list_app_todo_items table, which stores task descriptions, statuses (only \"pending\" or \"done\"), and timestamps.\n\nSecurity measures ensure the requesting user is authenticated and authorized to view only their own tasks. Validation of the {todoListAppUserId} as a UUID is performed. The response includes task summary details with pagination data.\n\nTypical usage includes client applications requesting the current user's task list with filter criteria, page size, and sort order.\n\nErrors include authorization failures if attempting to access other users' tasks and proper handling of invalid request parameters or server errors.","summary":"Retrieve a filtered and paginated list of todo items for a user","parameters":[{"name":"todoListAppUserId","in":"path","description":"Identifier of the user owning the todo items","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Search criteria and pagination parameters for todo items filtering","typeName":"ITodoListAppTodoItem.IRequest"},"responseBody":{"description":"Paginated list of todo item summary information matching search criteria","typeName":"IPageITodoListAppTodoItem.ISummary"},"authorizationType":null,"authorizationRole":"user","name":"index","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"patch","prerequisites":[{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"description":"The todo list app user must be created before retrieving todo items."}]},{"specification":"This operation retrieves detailed information about a specific todo item identified by its UUID and scoped to the owning user's UUID. It operates on the todo_list_app_todo_items table joined with the todo_list_app_users table for ownership verification.\n\nThe path parameters include the user's ID and the todo item's unique ID. The response returns comprehensive entity data including description, status (\"pending\" or \"done\"), and timestamps.\n\nSecurity and authorization focus on restricting access to the owning user only. The operation validates that the requesting user owns the todo item. Errors include not-found if the todo item doesn't exist or doesn't belong to the user. This operation uses HTTP GET to fetch detailed entity data.","description":"Retrieve detailed information about a specific todo item owned by the user identified by {todoListAppUserId} and the todo item identified by {id}.\n\nOnly the owning user is authorized to access this data. The todo item includes fields for description, status (\"pending\" or \"done\"), creation, and update timestamps.\n\nThis operation requires validation of both path parameters as UUIDs and enforces strict ownership checking.\n\nCommon errors are authorization failure if the item belongs to another user, and not found if the item does not exist.\n\nThe response provides full task details for client applications requiring display or editing functionality.","summary":"Get details of a specific todo item owned by a user","parameters":[{"name":"todoListAppUserId","in":"path","description":"Unique identifier of the user owning the todo item","schema":{"type":"string","format":"uuid"}},{"name":"id","in":"path","description":"Unique identifier of the todo item","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed information about the specified todo item","typeName":"ITodoListAppTodoItem"},"authorizationType":null,"authorizationRole":"user","name":"at","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}","method":"get","prerequisites":[{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"description":"The todo item must be created before retrieving detailed information about it."}]},{"specification":"This operation creates a new todo item for a specific user in the todoListAppTodoItems table. It requires the user ID as a path parameter and a request body containing the item's description and status. The operation validates the description length (max 256 characters, non-empty) and sets the initial status, which must be 'pending' or 'done'. It returns the created todo item entity with all its detailed properties including timestamps. This operation requires the user role 'user' as only authenticated users may create their own todo items.","description":"Creates a new todo item owned by the specified user. The description must be non-empty and at most 256 characters. Status must be either 'pending' or 'done', typically 'pending' at creation. The item is uniquely identified and timestamps for creation and last update are recorded.\n\nOnly the authenticated user owning the specified user ID may perform this operation. The system enforces ownership and validates input values.\n\nThe operation relates to the todo_list_app_todo_items table in the Prisma schema. It references todo_list_app_users via the foreign key todo_list_app_user_id. The response entity contains all standard todo item fields.\n\nErrors may occur if the description is invalid, if the status is not recognized, or if authorization fails.\n\nClient must supply the user ID in the path and a valid request body matching the ITodoListAppTodoItem.ICreate schema.\n\nRelated operations include retrieving the todo items list, updating existing items, and deleting items.","summary":"Create a new todo item for a user","parameters":[{"name":"todoListAppUserId","description":"Unique identifier of the owning todo list app user","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Creation info of the todo item","typeName":"ITodoListAppTodoItem.ICreate"},"responseBody":{"description":"Newly created todo item entity","typeName":"ITodoListAppTodoItem"},"authorizationType":null,"authorizationRole":"user","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post","name":"create","prerequisites":[]},{"specification":"This operation updates an existing todo item by its ID and user ID in the todo_list_app_todo_items table. It requires path parameters for both user ID and item ID, and a request body with updated description and/or status. The status value must be either 'pending' or 'done'. The operation enforces that only the authenticated user owning the todo item can perform the update. Upon success, it returns the updated todo item entity including all fields and timestamps.\n\nThe endpoint supports updating the description only if the item's status is 'pending', otherwise description update may be rejected by business logic. Status changes can mark the item as done. The operation supports full replacement or partial updates based on input.\n\nErrors may occur if ownership is invalid, item does not exist, or validation fails on description or status.\n\nClient must supply user ID and item ID as path parameters and data matching ITodoListAppTodoItem.IUpdate in the request body.\n\nRelated operations include creating new todo items, deleting todo items, and fetching todo items list.","description":"Updates an existing todo item owned by the specified user. Description changes are allowed only if the item is currently 'pending'. Status can be updated to 'done' or 'pending'.\n\nThe operation verifies user ownership and validates the description length and status value.\n\nThis operation manipulates the todo_list_app_todo_items DB table and relates to todo_list_app_users for ownership.\n\nRequest must include user ID and todo item ID in path and request body with updated fields matching ITodoListAppTodoItem.IUpdate.\n\nErrors returned include authorization failure, validation errors, or item not found errors.\n\nThis complements the create and delete operations for managing todo items.","summary":"Update an existing todo item","parameters":[{"name":"todoListAppUserId","description":"Unique identifier of the owning todo list app user","schema":{"type":"string","format":"uuid"}},{"name":"id","description":"Unique identifier of the todo item","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Updated data for the todo item","typeName":"ITodoListAppTodoItem.IUpdate"},"responseBody":{"description":"Updated todo item entity","typeName":"ITodoListAppTodoItem"},"authorizationType":null,"authorizationRole":"user","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}","method":"put","name":"update","prerequisites":[]},{"specification":"This operation deletes an existing todo item permanently by its ID and user ID from the todo_list_app_todo_items table. It requires path parameters for user ID and todo item ID. The operation enforces that only the authenticated user owning the todo item can perform the deletion. Upon success, no content is returned.\n\nThis is a hard delete operation since the todo_list_app_todo_items table does not store a soft delete timestamp. Deleting a todo item removes it permanently from the database.\n\nErrors include authorization failure, item not found, or internal errors.\n\nClient must supply user ID and todo item ID values in the path parameters.\n\nThis operation complements the creation and update operations for full lifecycle management of todo items.","description":"Deletes a todo item owned by the specified user. This operation permanently removes the record from the database.\n\nIt verifies ownership and returns no response content.\n\nThe todo_list_app_todo_items schema does not support soft delete, so this is a hard delete.\n\nErrors include authorization failure or item not found.\n\nClient must provide user ID and todo item ID in the path.\n\nRelated operations include creating, updating, and retrieving todo items.","summary":"Delete a todo item permanently","parameters":[{"name":"todoListAppUserId","description":"Unique identifier of the owning todo list app user","schema":{"type":"string","format":"uuid"}},{"name":"id","description":"Unique identifier of the todo item","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationType":null,"authorizationRole":"user","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}","method":"delete","name":"erase","prerequisites":[]}],"components":{"authorization":[{"name":"user","description":"Authenticated users who can create, read, update, and delete their own todo items. They have personal access to their tasks and can manage them fully.","kind":"member"}],"schemas":{"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","minimum":0,"description":"Current page number."},"limit":{"type":"integer","minimum":0,"description":"Limitation of records per a page."},"records":{"type":"integer","minimum":0,"description":"Total records in the database."},"pages":{"type":"integer","minimum":0,"description":"Total pages.\n\nEqual to {@link records} / {@link limit} with ceiling."}},"required":["current","limit","records","pages"],"description":"Page information."},"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"IPageITodoListAppTodoListAppUsers.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListAppTodoListAppUsers.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"IPageITodoListAppTodoItem.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination","description":"Page information."},"data":{"type":"array","items":{"$ref":"#/components/schemas/ITodoListAppTodoItem.ISummary"},"description":"List of records."}},"required":["pagination","data"],"description":"A page.\n\nCollection of records with pagination information."},"ITodoListAppUser.ICreate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"User's unique email address to be used for login and identity verification."},"password_hash":{"type":"string","description":"Hashed password for user authentication, never store plain text passwords."},"email_verified":{"type":"boolean","description":"Flag indicating whether the user's email address has been verified."}},"required":["email","password_hash","email_verified"],"description":"User account creation data required for registering a new user in the todo_list_app_users table.\n\nThis schema contains the essential fields needed to create a user: email address, hashed password, and email verification status.\n\nThese fields ensure secure authentication and registration support."},"ITodoListAppUser.IAuthorized":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the authorized user."},"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"}},"required":["id","token"],"description":"Authorization response containing JWT token and authenticated user ID.\n\nThis response is returned after successful authentication operations such as login and registration."},"ITodoListAppUser.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"User's registered email address used for login."},"password":{"type":"string","description":"Plain text password used for authentication verification."}},"required":["email","password"],"description":"User login credentials including email and plaintext password for verification during authentication."},"ITodoListAppUser.IRefresh":{"type":"object","properties":{"refreshToken":{"type":"string","description":"Refresh token provided during authentication, used to obtain new access tokens."}},"required":["refreshToken"],"description":"Refresh token request data containing the token used to renew JWT access tokens."},"ITodoListAppTodoListAppUsers.ISafe":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary Key identifying the user."},"email":{"type":"string","description":"User's unique email address for login and identity verification."},"email_verified":{"type":"boolean","description":"Indicates whether the user's email address has been verified."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was last updated."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp indicating when the user account was soft deleted, if applicable."}},"required":["id","email","email_verified","created_at","updated_at"],"description":"A safe view of a todo list app user account excluding sensitive fields such as password hashes.\n\nThis entity represents a user account with essential public properties.\n\nDeleted_at is nullable and only included when the user is soft deleted."},"ITodoListAppTodoListAppUsers.IRequest":{"type":"object","properties":{"page":{"oneOf":[{"type":"integer","format":"uint32"},{"type":"null"}],"description":"Page number of the paginated list."},"limit":{"oneOf":[{"type":"integer","format":"uint32"},{"type":"null"}],"description":"Limitation of records per a page."},"search":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Search term for filtering users by email or other indexed properties."},"email_verified":{"oneOf":[{"type":"boolean"},{"type":"null"}],"description":"Filter by whether the user's email is verified."},"sort_by":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Column name to sort the results by."},"order":{"oneOf":[{"type":"string"},{"type":"null"}],"description":"Sort order: ascending or descending."}},"required":[],"description":"Request parameters for searching and paginated retrieval of todo list app user accounts.\n\nSupports filtering, sorting, and paging options to refine the list search results.\n\nParameters such as page, limit, search text, email verification status, and sorting can be used."},"ITodoListAppTodoListAppUsers.IUpdate":{"type":"object","properties":{"email":{"type":"string","description":"User's unique email address for login and identity verification."},"password_hash":{"type":"string","description":"Hashed password for user authentication."},"email_verified":{"type":"boolean","description":"Indicates whether the user's email address has been verified."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was last updated."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp indicating when the user account was soft deleted, if applicable."}},"required":[],"description":"Details for updating a todo list app user account.\n\nProperties are optional and can be updated selectively.\n\nIncludes email, password hash, email verification status, and timestamps.\n\nNote that ownership and immutable fields such as the user ID are not included and cannot be updated here."},"ITodoListAppTodoListAppUsers":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary Key identifying the user."},"email":{"type":"string","description":"User's unique email address for login and identity verification."},"password_hash":{"type":"string","description":"Hashed password for user authentication."},"email_verified":{"type":"boolean","description":"Indicates whether the user's email address has been verified."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was last updated."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time"},{"type":"null"}],"description":"Timestamp indicating when the user account was soft deleted, if applicable."}},"required":["id","email","password_hash","email_verified","created_at","updated_at"],"description":"Represents the complete todo list app user account entity.\n\nIncludes identification, authentication credentials (password hash), verification status, and timestamps.\n\nDeleted_at is nullable and indicates soft deletion status."},"ITodoListAppTodoItem.IRequest":{"type":"object","properties":{"page":{"description":"Page number of the paginated results.\n\nPagination control that specifies which page of the full result set to retrieve.\n\nThis property is optional; if omitted, the default is the first page.","type":"integer","format":"int32"},"limit":{"description":"Maximum number of records to retrieve per page.\n\nUsed to limit the number of todo items returned in a single response.\n\nIf omitted, the default limit applies.","type":"integer","format":"int32"},"search":{"description":"A text keyword to filter todo items by description or other text fields.\n\nSupports case-insensitive substring matching targeting todo item descriptions.\n\nUsed to find tasks that contain the given text in descriptions.","type":"string"}},"required":[],"description":"Request DTO for filtering and paginating todo items.\n\nAllows clients to specify pagination parameters and search string to control which todo items are returned in lists.\n\nThis type is used for list and search operations of todo items."},"ITodoListAppTodoItem":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the todo item.\n\nPrimary key in the todo_list_app_todo_items table.\n\nRepresents a specific task owned by a user."},"todo_list_app_user_id":{"type":"string","format":"uuid","description":"Unique identifier of the user who owns this todo item.\n\nForeign key to todo_list_app_users table 'id' column.\n\nEstablishes ownership relationship between task and user."},"description":{"type":"string","description":"Task description text.\n\nDetailed text describing the todo item task.\n\nMaximum length limited by application logic to 256 characters.\n\nNon-empty string."},"status":{"oneOf":[{"const":"pending","description":"Task completion status.\n\nAllowed values are:\n- 'pending': task is not yet completed.\n- 'done': task has been completed."},{"const":"done","description":"Task completion status.\n\nAllowed values are:\n- 'pending': task is not yet completed.\n- 'done': task has been completed."}],"description":"Task completion status.\n\nAllowed values are:\n- 'pending': task is not yet completed.\n- 'done': task has been completed."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the todo item was created.\n\nAutomatically set and stored in ISO 8601 with timezone.\n\nUsed for sorting and audit purposes."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the todo item was last updated.\n\nReflects the last modification time of the todo item.\n\nAutomatically maintained by the system."}},"required":["id","todo_list_app_user_id","description","status","created_at","updated_at"],"description":"Main entity schema for todo list tasks.\n\nRepresents a single task owned by a user with identifiers, descriptive text, status flags, and audit timestamps."},"ITodoListAppTodoItem.ICreate":{"type":"object","properties":{"description":{"type":"string","description":"Task description text.\n\nUser provided text describing the todo item.\n\nMust be a non-empty string up to 256 characters."},"status":{"oneOf":[{"const":"pending","description":"Task completion status.\n\nAllowed values:\n- 'pending' when task is newly created.\n- 'done' if task is created in a completed state (rare)."},{"const":"done","description":"Task completion status.\n\nAllowed values:\n- 'pending' when task is newly created.\n- 'done' if task is created in a completed state (rare)."}],"description":"Task completion status.\n\nAllowed values:\n- 'pending' when task is newly created.\n- 'done' if task is created in a completed state (rare)."},"todo_list_app_user_id":{"type":"string","format":"uuid","description":"Unique identifier of the user who will own this todo item.\n\nMandatory foreign key to the todo_list_app_users table.\n\nThis field must be set by the system from authenticated user context in secure implementations."}},"required":["description","status","todo_list_app_user_id"],"description":"Request DTO for creating a new todo item.\n\nIncludes task description, completion status (usually 'pending'), and user ownership identifier.\n\nAuthorization ensures that todo_list_app_user_id matches the authenticated user."},"ITodoListAppTodoItem.IUpdate":{"type":"object","properties":{"description":{"type":"string","description":"Updated description of the todo item.\n\nMay be provided only if the todo item status is 'pending'.\n\nMaximum length 256 characters."},"status":{"oneOf":[{"const":"pending","description":"Updated task completion status.\n\nAllowed values are 'pending' or 'done'.\n\nAllows marking a task as complete or reopening it."},{"const":"done","description":"Updated task completion status.\n\nAllowed values are 'pending' or 'done'.\n\nAllows marking a task as complete or reopening it."}],"description":"Updated task completion status.\n\nAllowed values are 'pending' or 'done'.\n\nAllows marking a task as complete or reopening it."}},"required":[],"description":"Request DTO for updating todo items.\n\nIncludes optional fields for modifying the description and/or status.\n\nRestrictions apply to updates depending on the current status of the todo item."},"ITodoListAppTodoListAppUsers.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the todo list app user.\n\nThis is the primary key for identifying user accounts in the system."},"email":{"type":"string","description":"The unique email address of the user.\n\nThis email is used for login and communication and must be unique across all users."},"email_verified":{"type":"boolean","description":"Indicates whether the user's email address has been verified.\n\nA verified email means the user has confirmed ownership of the email address, enabling full access to the application features."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the user account was created.\n\nThis field records the exact time the account was initially registered and persisted."}},"required":["id","email","email_verified","created_at"],"description":"Summary information for todo list app user accounts.\n\nThis simplified schema includes essential identification and status fields used in list views or minimal user representations. It omits sensitive fields such as password hashes to ensure security and privacy.\n\nThe schema aligns with the todo_list_app_users table structure, reflecting user public information relevant to most application features."},"ITodoListAppTodoItem.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the todo item.\n\nThis is used to identify the todo task in the database and API endpoints."},"description":{"type":"string","description":"Text description of the todo item.\n\nShould be a non-empty string up to 256 characters describing the task to be performed."},"status":{"oneOf":[{"const":"pending","description":"Completion status of the todo item.\n\nAllowed values are 'pending' for incomplete tasks and 'done' for completed tasks."},{"const":"done","description":"Completion status of the todo item.\n\nAllowed values are 'pending' for incomplete tasks and 'done' for completed tasks."}],"description":"Completion status of the todo item.\n\nAllowed values are 'pending' for incomplete tasks and 'done' for completed tasks."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the todo item was created.\n\nRecords when the task was initially added to the todo list."}},"required":["id","description","status","created_at"],"description":"Summary data for todo items in the todo list application.\n\nThis schema includes only the most essential fields used for listing tasks, enabling efficient retrieval and display without sensitive or excessive details.\n\nIt corresponds to the todo_list_app_todo_items database schema with fields curated for secure and minimal data transfer."}}}},"created_at":"2025-09-30T15:15:37.498Z","completed_at":"2025-09-30T15:28:52.569Z","step":0,"missed":[]},{"id":"01999b3d-adc4-7474-8c71-e41472c4842f","type":"userMessage","contents":[{"type":"text","text":"Make the e2e test functions."}],"created_at":"2025-09-30T15:28:54.724Z"},{"type":"test","id":"01999b44-be4c-74f8-a6c6-cd0d2f0c5386","instruction":"Generate comprehensive end-to-end (E2E) test scenarios for a minimal Todo list application with features: adding new tasks, marking tasks as done, deleting tasks, and retrieving the list of tasks. Tests should cover normal operation of each API endpoint, validation of required fields, error scenarios such as deleting non-existent tasks, and data integrity checks to ensure tasks are correctly stored and updated.","files":[{"scenario":{"endpoint":{"path":"/auth/user/join","method":"post"},"draft":"Test successful user registration by creating a new user account with valid email and password. Verify that the system stores the user with unverified email status and returns JWT access and refresh tokens. Validate business rules such as email uniqueness and password hashing enforcement. Ensure the response contains authorized user data with tokens to enable authenticated interaction with the todo list app.","functionName":"test_api_user_registration_successful","dependencies":[]},"location":"test/features/api/auth/test_api_user_registration_successful.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\nexport async function test_api_user_registration_successful(\n  connection: api.IConnection,\n) {\n  // Generate a realistic email address\n  const email = `user_${RandomGenerator.alphaNumeric(8)}@example.com`;\n\n  // Simulate a password hash string (dummy hashed password format)\n  const passwordHash = RandomGenerator.alphaNumeric(64); // 64 char alphanumeric\n\n  // Create the user registration data\n  const userCreateBody = {\n    email: email as string & tags.Format<\"email\">,\n    password_hash: passwordHash,\n    email_verified: false,\n  } satisfies ITodoListAppUser.ICreate;\n\n  // Call the join API to register the user\n  const authorizedUser: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: userCreateBody,\n    });\n  // Assert the API response type correctness including UUID and token\n  typia.assert(authorizedUser);\n\n  // Validate that user ID is a UUID string\n  TestValidator.predicate(\n    \"user ID must be UUID format\",\n    /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(\n      authorizedUser.id,\n    ),\n  );\n\n  // Basic checks on authorization token properties\n  TestValidator.predicate(\n    \"authorization token access is non-empty string\",\n    typeof authorizedUser.token.access === \"string\" &&\n      authorizedUser.token.access.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"authorization token refresh is non-empty string\",\n    typeof authorizedUser.token.refresh === \"string\" &&\n      authorizedUser.token.refresh.length > 0,\n  );\n\n  TestValidator.predicate(\n    \"authorization token expired_at is ISO date-time string\",\n    !isNaN(Date.parse(authorizedUser.token.expired_at)) &&\n      typeof authorizedUser.token.expired_at === \"string\",\n  );\n\n  TestValidator.predicate(\n    \"authorization token refreshable_until is ISO date-time string\",\n    !isNaN(Date.parse(authorizedUser.token.refreshable_until)) &&\n      typeof authorizedUser.token.refreshable_until === \"string\",\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}","method":"get"},"draft":"Test the retrieval of detailed information for a specific todo item owned by the authenticated user. The test involves:\n1. Registering a new user to create a fresh user context.\n2. Creating a new todo item under this user account with valid description and status 'pending'.\n3. Retrieving the details of the created todo item and verifying that the data matches the created item, including description, status, and timestamps.\n4. Validating that unauthorized access is not possible by attempting to retrieve a todo item belonging to another user (this negative test can be implemented separately).\nThis test verifies ownership enforcement, data integrity, and correct detailed information retrieval for todo items.","functionName":"test_api_todo_item_detail_retrieval_by_owner","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Authenticate as a new user to create and access todo items"},{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"purpose":"Create a todo item for the authenticated user before retrieving its details"}]},"location":"test/features/api/todoitem/test_api_todo_item_detail_retrieval_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\nexport async function test_api_todo_item_detail_retrieval_by_owner(\n  connection: api.IConnection,\n) {\n  // Register a new user and assert correct registration\n  const userCreateBody = {\n    email: `${RandomGenerator.name(1)}@example.com`,\n    password_hash: RandomGenerator.alphaNumeric(16),\n    email_verified: true,\n  } satisfies ITodoListAppUser.ICreate;\n\n  const authorizedUser = await api.functional.auth.user.join(connection, {\n    body: userCreateBody,\n  });\n  typia.assert(authorizedUser);\n\n  // Create a new todo item for the authenticated user\n  const todoCreateBody = {\n    description: RandomGenerator.paragraph({\n      sentences: 5,\n      wordMin: 3,\n      wordMax: 8,\n    }),\n    status: \"pending\",\n    todo_list_app_user_id: authorizedUser.id,\n  } satisfies ITodoListAppTodoItem.ICreate;\n\n  const createdTodo =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.create(\n      connection,\n      {\n        todoListAppUserId: authorizedUser.id,\n        body: todoCreateBody,\n      },\n    );\n  typia.assert(createdTodo);\n\n  // Retrieve the todo item details by user and todo item IDs\n  const retrievedTodo =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.at(\n      connection,\n      {\n        todoListAppUserId: authorizedUser.id,\n        id: createdTodo.id,\n      },\n    );\n  typia.assert(retrievedTodo);\n\n  // Validate that retrieved data matches the created todo item\n  TestValidator.equals(\n    \"todo item ID matches\",\n    retrievedTodo.id,\n    createdTodo.id,\n  );\n  TestValidator.equals(\n    \"todo item user ID matches\",\n    retrievedTodo.todo_list_app_user_id,\n    authorizedUser.id,\n  );\n  TestValidator.equals(\n    \"todo item description matches\",\n    retrievedTodo.description,\n    todoCreateBody.description,\n  );\n  TestValidator.equals(\n    \"todo item status matches\",\n    retrievedTodo.status,\n    todoCreateBody.status,\n  );\n  // Validate that created_at and updated_at timestamps exist and are strings\n  TestValidator.predicate(\n    \"todo item created_at is a non-empty string\",\n    typeof retrievedTodo.created_at === \"string\" &&\n      retrievedTodo.created_at.length > 0,\n  );\n  TestValidator.predicate(\n    \"todo item updated_at is a non-empty string\",\n    typeof retrievedTodo.updated_at === \"string\" &&\n      retrievedTodo.updated_at.length > 0,\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"draft":"Test the creation of a new todo item for an authenticated user. The test includes:\n1. Registering a new user to establish a fresh user context.\n2. Creating a todo item with a valid non-empty description and a status of 'pending' for this user.\n3. Verifying that the response includes the created todo item details with expected fields such as description, status, and timestamps.\n4. Validating error handling for invalid descriptions or unauthorized creation attempts can be included in other test cases.\nThis scenario confirms the successful creation workflow and authorization enforcement for adding todo items.","functionName":"test_api_todo_item_creation_by_authenticated_user","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Authenticate as a new user to create todo items"}]},"location":"test/features/api/todo_list_app/test_api_todo_item_creation_by_authenticated_user.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\n/**\n * Test the creation of a new todo item for an authenticated user.\n *\n * This test covers:\n *\n * 1. User registration with valid email, password_hash, and email_verified set to\n *    true.\n * 2. Creation of a todo item with a valid non-empty description and status\n *    \"pending\".\n * 3. Verification that the response includes expected fields with correct types\n *    and values.\n * 4. Business logic validation ensuring data integrity and consistency.\n */\nexport async function test_api_todo_item_creation_by_authenticated_user(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user to get an authenticated context\n  const userBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password_hash: RandomGenerator.alphaNumeric(32),\n    email_verified: true,\n  } satisfies ITodoListAppUser.ICreate;\n\n  const authorizedUser: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: userBody,\n    });\n  typia.assert(authorizedUser);\n\n  // 2. Create a new todo item with valid description and status 'pending'\n  const todoItemBody = {\n    description: RandomGenerator.paragraph({\n      sentences: 5,\n      wordMin: 4,\n      wordMax: 8,\n    }),\n    status: \"pending\",\n    todo_list_app_user_id: authorizedUser.id,\n  } satisfies ITodoListAppTodoItem.ICreate;\n\n  const todoItem: ITodoListAppTodoItem =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.create(\n      connection,\n      {\n        todoListAppUserId: authorizedUser.id,\n        body: todoItemBody,\n      },\n    );\n\n  // 3. Assert the returned todo item\n  typia.assert(todoItem);\n\n  // 4. Business logic checks\n  TestValidator.equals(\n    \"todo item user id matches authenticated user\",\n    todoItem.todo_list_app_user_id,\n    authorizedUser.id,\n  );\n  TestValidator.predicate(\n    \"todo item description is a non-empty string\",\n    todoItem.description.length > 0,\n  );\n  TestValidator.equals(\n    \"todo item status is 'pending'\",\n    todoItem.status,\n    \"pending\",\n  );\n\n  // Validate date format for created_at and updated_at\n  TestValidator.predicate(\n    \"todo item created_at is valid ISO 8601 date\",\n    typeof todoItem.created_at === \"string\" &&\n      !isNaN(Date.parse(todoItem.created_at)),\n  );\n  TestValidator.predicate(\n    \"todo item updated_at is valid ISO 8601 date\",\n    typeof todoItem.updated_at === \"string\" &&\n      !isNaN(Date.parse(todoItem.updated_at)),\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}","method":"put"},"draft":"Ensure that an authenticated user can update their own todo item's description only if the item's status is 'pending'. The test involves:\n1. Registering a new user to create a fresh user context.\n2. Creating a new todo item with status 'pending'.\n3. Updating the todo item's description and/or status to 'done'.\n4. Verifying the update is successful and that the data reflects the changes.\n5. Confirming that updates to description are rejected or forbidden if the status is not 'pending' in separate negative tests.\nThis validates ownership enforcement, business rules on update conditions, and data consistency during updates.","functionName":"test_api_todo_item_update_by_owner_with_pending_status","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Authenticate as a new user to update todo items"},{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"purpose":"Create a todo item before attempting to update it"}]},"location":"test/features/api/todo/test_api_todo_item_update_by_owner_with_pending_status.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\n/**\n * Test the update functionality of a user's todo item with strict status\n * checks.\n *\n * This test validates the correct behavior when a user attempts to update their\n * todo item only if its current status is 'pending'.\n *\n * Process:\n *\n * 1. Register a new user using valid email and password hash with email verified\n *    status.\n * 2. Create a new todo item owned by the registered user with initial status\n *    'pending' and a random description.\n * 3. Attempt to update the description and status of the todo item to 'done' and\n *    verify success.\n * 4. Reload the todo item and verify the updated fields match the changes.\n * 5. Attempt invalid updates:\n *\n *    - Try to update the description again after status is 'done', which should fail\n *         with an error due to business rules.\n * 6. Confirm error handling for unauthorized modification attempts by another user\n *    if applicable.\n */\nexport async function test_api_todo_item_update_by_owner_with_pending_status(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user\n  const email = `test_${RandomGenerator.alphaNumeric(8)}@example.com`;\n  const passwordHash = RandomGenerator.alphaNumeric(64);\n  const emailVerified = true;\n  const userCreateBody = {\n    email,\n    password_hash: passwordHash,\n    email_verified: emailVerified,\n  } satisfies ITodoListAppUser.ICreate;\n\n  const userAuthorized: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, { body: userCreateBody });\n  typia.assert(userAuthorized);\n\n  // Extract user ID and token\n  const userId = userAuthorized.id;\n\n  // 2. Create a new todo item with status 'pending'\n  const todoDescription = RandomGenerator.paragraph({\n    sentences: 3,\n    wordMin: 5,\n    wordMax: 10,\n  });\n  const todoCreateBody = {\n    description: todoDescription,\n    status: \"pending\",\n    todo_list_app_user_id: userId,\n  } satisfies ITodoListAppTodoItem.ICreate;\n\n  const todoItem: ITodoListAppTodoItem =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.create(\n      connection,\n      {\n        todoListAppUserId: userId,\n        body: todoCreateBody,\n      },\n    );\n  typia.assert(todoItem);\n\n  // 3. Update the todo item's description and status to 'done'\n  const updatedDescription = todoDescription + \" updated\";\n  const updateBody1 = {\n    description: updatedDescription,\n    status: \"done\",\n  } satisfies ITodoListAppTodoItem.IUpdate;\n\n  const updatedTodoItem: ITodoListAppTodoItem =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.update(\n      connection,\n      {\n        todoListAppUserId: userId,\n        id: todoItem.id,\n        body: updateBody1,\n      },\n    );\n  typia.assert(updatedTodoItem);\n\n  // 4. Verify update result\n  TestValidator.equals(\n    \"description updated\",\n    updatedTodoItem.description,\n    updatedDescription,\n  );\n  TestValidator.equals(\"status updated\", updatedTodoItem.status, \"done\");\n\n  // 5. Attempt to update description again after status is 'done' - should fail\n  const updateBodyInvalid = {\n    description: updatedDescription + \" again\",\n  } satisfies ITodoListAppTodoItem.IUpdate;\n\n  await TestValidator.error(\n    \"should fail to update description on done status\",\n    async () => {\n      await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.update(\n        connection,\n        {\n          todoListAppUserId: userId,\n          id: todoItem.id,\n          body: updateBodyInvalid,\n        },\n      );\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}","method":"delete"},"draft":"Test the permanent deletion of a todo item by its owning authenticated user. The workflow is:\n1. Register a new user to establish a fresh user context.\n2. Create a todo item for this user.\n3. Delete the created todo item by the same user.\n4. Attempt to retrieve the deleted item to confirm it no longer exists, expecting a not-found error.\n5. Ensure that unauthorized users cannot delete todo items they do not own (can be a separate negative test).\nThis test verifies authorization, permanent deletion behavior, and data integrity enforcement.","functionName":"test_api_todo_item_deletion_by_owner","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Authenticate as a new user to delete todo items"},{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"purpose":"Create a todo item before deletion"}]},"location":"test/features/api/todo_list_app/test_api_todo_item_deletion_by_owner.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\nexport async function test_api_todo_item_deletion_by_owner(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user\n  const email1 = typia.random<string & tags.Format<\"email\">>();\n  const user1: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: email1,\n        password_hash: RandomGenerator.alphaNumeric(32),\n        email_verified: true,\n      } satisfies ITodoListAppUser.ICreate,\n    });\n  typia.assert(user1);\n\n  // 2. Create a todo item for this user\n  const todoDescription = RandomGenerator.paragraph({ sentences: 3 });\n  const todoInput = {\n    description: todoDescription,\n    status: \"pending\",\n    todo_list_app_user_id: user1.id,\n  } satisfies ITodoListAppTodoItem.ICreate;\n\n  const todoItem: ITodoListAppTodoItem =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.create(\n      connection,\n      {\n        todoListAppUserId: user1.id,\n        body: todoInput,\n      },\n    );\n  typia.assert(todoItem);\n\n  TestValidator.equals(\n    \"todoItem owner matches user1\",\n    todoItem.todo_list_app_user_id,\n    user1.id,\n  );\n\n  // 3. Delete the created todo item by the same user\n  await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.erase(\n    connection,\n    {\n      todoListAppUserId: user1.id,\n      id: todoItem.id,\n    },\n  );\n\n  // 4. Attempt to delete the same todo item again, expect failure\n  await TestValidator.error(\n    \"deleting already deleted todo item should fail\",\n    async () => {\n      await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.erase(\n        connection,\n        {\n          todoListAppUserId: user1.id,\n          id: todoItem.id,\n        },\n      );\n    },\n  );\n\n  // 5. Negative test: Second user cannot delete first user's todo item\n  const email2 = typia.random<string & tags.Format<\"email\">>();\n  const user2: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: {\n        email: email2,\n        password_hash: RandomGenerator.alphaNumeric(32),\n        email_verified: true,\n      } satisfies ITodoListAppUser.ICreate,\n    });\n  typia.assert(user2);\n\n  // Since todoItem is deleted, create another todo for user1 to test negative case\n  const todoItem2: ITodoListAppTodoItem =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.create(\n      connection,\n      {\n        todoListAppUserId: user1.id,\n        body: {\n          description: RandomGenerator.paragraph({ sentences: 2 }),\n          status: \"pending\",\n          todo_list_app_user_id: user1.id,\n        } satisfies ITodoListAppTodoItem.ICreate,\n      },\n    );\n  typia.assert(todoItem2);\n\n  await TestValidator.error(\n    \"user2 cannot delete user1's todo item\",\n    async () => {\n      await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.erase(\n        connection,\n        {\n          todoListAppUserId: user2.id,\n          id: todoItem2.id,\n        },\n      );\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoListApp/user/todoListAppUsers","method":"patch"},"draft":"Test the user search and retrieval flow for todo list app users. This scenario covers creating a new user via the join endpoint to authenticate, then performing a search with specific filters such as email substring and verification status. It validates that the paginated list returns matching users according to search criteria. The workflow includes: 1) Register a new user with /auth/user/join to create a fresh user context, 2) Use JWT token to call the user search endpoint with filters like email substring or verification status, 3) Verify that the response contains a paginated list of user summary information respecting the filters, 4) Confirm the API returns 200 status and the data matches user search criteria. This scenario ensures proper authentication and validation of pagination, sorting, and filtering features for user accounts management.","functionName":"test_api_todo_list_app_user_search_and_retrieve_paginated_filtered_list","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Authenticate as user by joining a new account for search permission"},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/user/join) must be executed before any operations requiring 'user' role authorization. \nIt establishes the necessary user account and authentication context for the 'user' role, enabling subsequent API calls that depend on this specific authorization level. \nWithout this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/todo_list_app_user/test_api_todo_list_app_user_search_and_retrieve_paginated_filtered_list.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListAppTodoListAppUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAppTodoListAppUsers\";\nimport type { ITodoListAppTodoListAppUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoListAppUsers\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\nexport async function test_api_todo_list_app_user_search_and_retrieve_paginated_filtered_list(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user via /auth/user/join\n  const emailForJoin = `testuser_${RandomGenerator.alphaNumeric(6)}@example.com`;\n  const passwordForJoin = `pass_${RandomGenerator.alphaNumeric(8)}`;\n  const joinBody = {\n    email: emailForJoin,\n    password_hash: passwordForJoin,\n    email_verified: RandomGenerator.pick([true, false] as const),\n  } satisfies ITodoListAppUser.ICreate;\n\n  const authorizedUser = await api.functional.auth.user.join(connection, {\n    body: joinBody,\n  });\n  typia.assert(authorizedUser);\n  TestValidator.predicate(\"user id is uuid\", !!authorizedUser.id);\n\n  // 2. Perform search via todoListAppUsers.index with filters\n  // Create multiple realistic search requests to test filtering\n\n  const searchTests: {\n    description: string;\n    requestBody: ITodoListAppTodoListAppUsers.IRequest;\n  }[] = [];\n\n  // Search with email substring exactly matching the joined user email substring (e.g. testuser_)\n  searchTests.push({\n    description: \"Search users with email containing 'testuser_'\",\n    requestBody: {\n      page: 1,\n      limit: 10,\n      search: \"testuser_\",\n      email_verified: null,\n      sort_by: \"created_at\",\n      order: \"desc\",\n    } satisfies ITodoListAppTodoListAppUsers.IRequest,\n  });\n\n  // Search with email_verified true\n  searchTests.push({\n    description: \"Search users with email_verified true\",\n    requestBody: {\n      page: 1,\n      limit: 10,\n      search: null,\n      email_verified: true,\n      sort_by: \"created_at\",\n      order: \"asc\",\n    } satisfies ITodoListAppTodoListAppUsers.IRequest,\n  });\n\n  // Search with email_verified false\n  searchTests.push({\n    description: \"Search users with email_verified false\",\n    requestBody: {\n      page: 1,\n      limit: 10,\n      search: null,\n      email_verified: false,\n      sort_by: \"email\",\n      order: \"asc\",\n    } satisfies ITodoListAppTodoListAppUsers.IRequest,\n  });\n\n  // Search with no filter (all users)\n  searchTests.push({\n    description: \"Search users with no filters\",\n    requestBody: {\n      page: 1,\n      limit: 20,\n      search: null,\n      email_verified: null,\n      sort_by: null,\n      order: null,\n    } satisfies ITodoListAppTodoListAppUsers.IRequest,\n  });\n\n  // Execute all searches and validate results\n  for (const test of searchTests) {\n    const result: IPageITodoListAppTodoListAppUsers.ISummary =\n      await api.functional.todoListApp.user.todoListAppUsers.index(connection, {\n        body: test.requestBody,\n      });\n    typia.assert(result);\n\n    TestValidator.predicate(\n      `Pagination has positive current page for: ${test.description}`,\n      result.pagination.current > 0,\n    );\n    TestValidator.predicate(\n      `Pagination limit is positive for: ${test.description}`,\n      result.pagination.limit > 0,\n    );\n    TestValidator.predicate(\n      `Pagination pages is non-negative for: ${test.description}`,\n      result.pagination.pages >= 0,\n    );\n\n    // Validate each user matches search criteria\n    for (const user of result.data) {\n      typia.assert(user);\n      TestValidator.predicate(\n        `User id is uuid for: ${test.description}`,\n        /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(\n          user.id,\n        ),\n      );\n\n      TestValidator.predicate(\n        `User email string present for: ${test.description}`,\n        typeof user.email === \"string\" && user.email.length > 0,\n      );\n\n      // Validate email_verified filter if used\n      if (\n        test.requestBody.email_verified !== null &&\n        test.requestBody.email_verified !== undefined\n      ) {\n        TestValidator.equals(\n          `User email_verified matches filter for: ${test.description}`,\n          user.email_verified,\n          test.requestBody.email_verified,\n        );\n      }\n\n      // Validate email contains search substring if search is used\n      if (\n        test.requestBody.search !== null &&\n        test.requestBody.search !== undefined\n      ) {\n        TestValidator.predicate(\n          `User email contains search string for: ${test.description}`,\n          user.email.includes(test.requestBody.search),\n        );\n      }\n    }\n  }\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/login","method":"post"},"draft":"Test login process for a user with verified email and correct credentials. Steps:\n1. Register a new user via /auth/user/join to create a fresh user context (user is initially email_verified=false).\n2. Simulate or assume email verification (for the sake of test, assume the user is verified).\n3. Attempt login via /auth/user/login with correct email and password.\n4. Validate that the response includes JWT access and refresh tokens.\n5. Test failure case where login is attempted with incorrect password.\n6. Test failure case where login is attempted for unverified email.\nEnsure authentication tokens are properly issued only for verified, active users.","functionName":"test_api_user_login_with_existing_account","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create new user account for login testing"}]},"location":"test/features/api/userauth/test_api_user_login_with_existing_account.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\n/**\n * E2E test for user login with existing account including registration, login\n * success, login failures due to wrong password and unverified email.\n *\n * Workflow:\n *\n * 1. Register user via /auth/user/join with email_verified: false\n * 2. Simulate email verification boolean to true for login success test.\n * 3. Call /auth/user/login with correct credentials and verify tokens\n * 4. Call /auth/user/login with wrong password and verify error\n * 5. Call /auth/user/login with unverified email and verify error\n */\nexport async function test_api_user_login_with_existing_account(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user with email_verified false\n  const email = typia.random<string & tags.Format<\"email\">>();\n  const password = RandomGenerator.alphaNumeric(12);\n  // Password hash must be generated but since API needs hash string, we simulate by using plain password again (not realistic but testable).\n  // Assuming API has hashing internally or we provide raw string as per description.\n  const userCreate = {\n    email: email,\n    password_hash: password, // test assumes this is acceptable\n    email_verified: false,\n  } satisfies ITodoListAppUser.ICreate;\n  const joinedUser = await api.functional.auth.user.join(connection, {\n    body: userCreate,\n  });\n  typia.assert(joinedUser);\n\n  // 2. Simulate email verified user for login success\n  const verifiedUserCreate = {\n    email: email,\n    password_hash: password,\n    email_verified: true,\n  } satisfies ITodoListAppUser.ICreate;\n  // Join again or simulate verification internally is not supported,\n  // so we manually reuse email and password for login\n\n  // 3. Successful login with correct credentials\n  const loginBody = {\n    email: email,\n    password: password,\n  } satisfies ITodoListAppUser.ILogin;\n  const loginResponse = await api.functional.auth.user.login(connection, {\n    body: loginBody,\n  });\n  typia.assert(loginResponse);\n  TestValidator.predicate(\n    \"Login returns user id\",\n    typeof loginResponse.id === \"string\" && loginResponse.id.length > 0,\n  );\n  TestValidator.predicate(\n    \"Login returns access token\",\n    typeof loginResponse.token.access === \"string\" &&\n      loginResponse.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"Login returns refresh token\",\n    typeof loginResponse.token.refresh === \"string\" &&\n      loginResponse.token.refresh.length > 0,\n  );\n  TestValidator.predicate(\n    \"Login returns expired_at\",\n    typeof loginResponse.token.expired_at === \"string\" &&\n      loginResponse.token.expired_at.length > 0,\n  );\n  TestValidator.predicate(\n    \"Login returns refreshable_until\",\n    typeof loginResponse.token.refreshable_until === \"string\" &&\n      loginResponse.token.refreshable_until.length > 0,\n  );\n\n  // 4. Fail login with wrong password but verified email\n  const wrongPasswordBody = {\n    email: email,\n    password: password + \"X\",\n  } satisfies ITodoListAppUser.ILogin;\n  await TestValidator.error(\"Login fails with wrong password\", async () => {\n    await api.functional.auth.user.login(connection, {\n      body: wrongPasswordBody,\n    });\n  });\n\n  // 5. Fail login with unverified email\n  // For unverified email test, we have to register a user with email_verified false\n  const unverifiedEmail = typia.random<string & tags.Format<\"email\">>();\n  const unverifiedUserCreate = {\n    email: unverifiedEmail,\n    password_hash: password,\n    email_verified: false,\n  } satisfies ITodoListAppUser.ICreate;\n  await api.functional.auth.user.join(connection, {\n    body: unverifiedUserCreate,\n  });\n  const unverifiedLoginBody = {\n    email: unverifiedEmail,\n    password: password,\n  } satisfies ITodoListAppUser.ILogin;\n  await TestValidator.error(\"Login fails with unverified email\", async () => {\n    await api.functional.auth.user.login(connection, {\n      body: unverifiedLoginBody,\n    });\n  });\n}\n"},{"scenario":{"endpoint":{"path":"/auth/user/refresh","method":"post"},"draft":"Test token refresh operation to obtain new JWT access tokens without re-login.\n1. Register a new user via /auth/user/join.\n2. Login to get initial JWT tokens.\n3. Use obtained refresh token to call /auth/user/refresh.\n4. Validate new access token and refresh token are returned.\n5. Test with invalid or expired refresh token to verify proper error handling.","functionName":"test_api_user_token_refresh_with_valid_refresh_token","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Create new user account for token refresh testing"},{"endpoint":{"method":"post","path":"/auth/user/login"},"purpose":"Login existing user to get initial refresh token"}]},"location":"test/features/api/user/test_api_user_token_refresh_with_valid_refresh_token.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\n/**\n * Comprehensive E2E test for token refresh functionality of todo list app user\n * authentication.\n *\n * This test covers the full user authentication workflow:\n *\n * 1. User registration via /auth/user/join with valid email and password hash.\n * 2. User login via /auth/user/login to obtain access and refresh tokens.\n * 3. Token refresh by posting refresh token to /auth/user/refresh to receive new\n *    tokens.\n * 4. Verification that new tokens differ from initial tokens.\n * 5. Error scenario test for refresh with invalid token.\n *\n * All validations include typia asserts for complete type safety and\n * TestValidator to verify logical correctness.\n */\nexport async function test_api_user_token_refresh_with_valid_refresh_token(\n  connection: api.IConnection,\n) {\n  // Step 1: User registration\n  const userEmail = `e2e_test_${RandomGenerator.alphaNumeric(10)}@example.com`;\n  const passwordPlain = \"StrongP@ssw0rd!\";\n  const passwordHash = `hashed_${passwordPlain}`;\n  const createBody = {\n    email: userEmail,\n    password_hash: passwordHash,\n    email_verified: true,\n  } satisfies ITodoListAppUser.ICreate;\n  const createdUser: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: createBody,\n    });\n  typia.assert(createdUser);\n\n  // Step 2: User login\n  const loginBody = {\n    email: userEmail,\n    password: passwordPlain,\n  } satisfies ITodoListAppUser.ILogin;\n  const loginResult: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.login(connection, {\n      body: loginBody,\n    });\n  typia.assert(loginResult);\n\n  // Extract the initial tokens\n  const initialAccessToken = loginResult.token.access;\n  const initialRefreshToken = loginResult.token.refresh;\n\n  // Tokens should be non-empty strings\n  TestValidator.predicate(\n    \"initial access token is a non-empty string\",\n    typeof initialAccessToken === \"string\" && initialAccessToken.length > 0,\n  );\n  TestValidator.predicate(\n    \"initial refresh token is a non-empty string\",\n    typeof initialRefreshToken === \"string\" && initialRefreshToken.length > 0,\n  );\n\n  // Step 3: Use refresh token to obtain new tokens\n  const refreshBody = {\n    refreshToken: initialRefreshToken,\n  } satisfies ITodoListAppUser.IRefresh;\n  const refreshedResult: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.refresh(connection, {\n      body: refreshBody,\n    });\n  typia.assert(refreshedResult);\n\n  // Step 4: Validate tokens are new and valid\n  TestValidator.predicate(\n    \"refreshed access token is a non-empty string\",\n    typeof refreshedResult.token.access === \"string\" &&\n      refreshedResult.token.access.length > 0,\n  );\n  TestValidator.predicate(\n    \"refreshed refresh token is a non-empty string\",\n    typeof refreshedResult.token.refresh === \"string\" &&\n      refreshedResult.token.refresh.length > 0,\n  );\n\n  TestValidator.notEquals(\n    \"access token must differ after refresh\",\n    refreshedResult.token.access,\n    initialAccessToken,\n  );\n  TestValidator.notEquals(\n    \"refresh token must differ after refresh\",\n    refreshedResult.token.refresh,\n    initialRefreshToken,\n  );\n\n  // Step 5: Error scenario - invalid refresh token\n  await TestValidator.error(\n    \"refresh with invalid token must fail\",\n    async () => {\n      await api.functional.auth.user.refresh(connection, {\n        body: {\n          refreshToken: \"invalid-token\",\n        } satisfies ITodoListAppUser.IRefresh,\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{id}","method":"get"},"draft":"Test retrieval of detailed user information by user ID.\n1. Authenticate as user using /auth/user/join to create new user context.\n2. Create a todo item for the user as prerequisite.\n3. Retrieve user information by the user's ID via /todoListApp/user/todoListAppUsers/{id}.\n4. Validate returned data includes email, email_verified, created_at, updated_at but excludes password hash.\n5. Test unauthorized access is rejected.\n6. Test retrieval of non-existent user returns appropriate error.","functionName":"test_api_user_detailed_information_retrieval","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate and create new user context"},{"endpoint":{"method":"post","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems"},"purpose":"Create a todo item for the user before retrieving detailed user information"}]},"location":"test/features/api/todo_list_app_user/test_api_user_detailed_information_retrieval.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport type { ITodoListAppTodoListAppUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoListAppUsers\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\nexport async function test_api_user_detailed_information_retrieval(\n  connection: api.IConnection,\n) {\n  // 1. Create and authenticate a new user\n  const userCreateBody = {\n    email: `${RandomGenerator.alphaNumeric(8)}@example.com`,\n    password_hash: RandomGenerator.alphaNumeric(20),\n    email_verified: false,\n  } satisfies ITodoListAppUser.ICreate;\n\n  const authorizedUser = await api.functional.auth.user.join(connection, {\n    body: userCreateBody,\n  });\n  typia.assert(authorizedUser);\n\n  // 2. Create a todo item for the user as prerequisite\n  const todoCreateBody = {\n    description: RandomGenerator.paragraph({\n      sentences: 5,\n      wordMin: 3,\n      wordMax: 10,\n    }),\n    status: \"pending\",\n    todo_list_app_user_id: authorizedUser.id,\n  } satisfies ITodoListAppTodoItem.ICreate;\n\n  const todoItem =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.create(\n      connection,\n      {\n        todoListAppUserId: authorizedUser.id,\n        body: todoCreateBody,\n      },\n    );\n  typia.assert(todoItem);\n\n  // 3. Retrieve the user information by ID\n  const retrievedUser =\n    await api.functional.todoListApp.user.todoListAppUsers.at(connection, {\n      id: authorizedUser.id,\n    });\n  typia.assert(retrievedUser);\n\n  // Validate returned fields\n  TestValidator.equals(\n    \"retrieved user email\",\n    retrievedUser.email,\n    userCreateBody.email,\n  );\n  TestValidator.equals(\n    \"retrieved user email_verified flag\",\n    retrievedUser.email_verified,\n    userCreateBody.email_verified,\n  );\n\n  // Check created_at and updated_at are strings with date-time format\n  TestValidator.predicate(\n    \"created_at is a valid ISO 8601 date\",\n    typeof retrievedUser.created_at === \"string\" &&\n      /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z$/.test(\n        retrievedUser.created_at,\n      ),\n  );\n  TestValidator.predicate(\n    \"updated_at is a valid ISO 8601 date\",\n    typeof retrievedUser.updated_at === \"string\" &&\n      /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z$/.test(\n        retrievedUser.updated_at,\n      ),\n  );\n\n  // Ensure password_hash is not included in retrieved user\n  TestValidator.predicate(\n    \"password_hash is not present in retrieved user\",\n    !(\"password_hash\" in retrievedUser),\n  );\n\n  // 4. Test unauthorized access is rejected\n  // To simulate unauthorized, use a new connection without auth token\n  const unauthorizedConnection: api.IConnection = {\n    ...connection,\n    headers: {},\n  };\n  await TestValidator.error(\"unauthorized access rejected\", async () => {\n    await api.functional.todoListApp.user.todoListAppUsers.at(\n      unauthorizedConnection,\n      { id: authorizedUser.id },\n    );\n  });\n\n  // 5. Test retrieval of non-existent user returns error\n  await TestValidator.error(\n    \"retrieval of non-existent user fails\",\n    async () => {\n      await api.functional.todoListApp.user.todoListAppUsers.at(connection, {\n        id: typia.random<string & tags.Format<\"uuid\">>(),\n      });\n    },\n  );\n}\n"},{"scenario":{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{id}","method":"put"},"draft":"Test the process of updating an existing todo list app user account after creating a todo item for the user. The scenario includes registering a new user with '/auth/user/join' to create the user account, authenticating the user implicitly in the join step, creating a new todo item owned by the user, and then updating the user's details. The test verifies proper authorization, ownership enforcement, and validation of update constraints, ensuring that user modifications only occur if the user is authenticated and has existing todo items. Expected outcomes include successful creation of the user and todo item, proper updating of the user details, and validation that unauthorized updates fail.","functionName":"test_api_todo_list_app_user_update_with_todo_item_dependency","dependencies":[{"endpoint":{"path":"/auth/user/join","method":"post"},"purpose":"Authenticate as user to create test user account with join operation"},{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"post"},"purpose":"Create a todo item owned by the user before updating user information"},{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Essential authentication prerequisite: \nThis join operation (post /auth/user/join) must be executed before any operations requiring 'user' role authorization. \nIt establishes the necessary user account and authentication context for the 'user' role, enabling subsequent API calls that depend on this specific authorization level. \nWithout this join operation, the main scenario endpoint and its dependencies will fail due to insufficient authentication credentials."}]},"location":"test/features/api/todo_list_app/test_api_todo_list_app_user_update_with_todo_item_dependency.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport type { ITodoListAppTodoListAppUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoListAppUsers\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\n/**\n * This E2E test covers the complete workflow of updating a todo list app user\n * after creating a todo item owned by the user. The test first registers a new\n * user account via the POST /auth/user/join endpoint, obtaining authenticated\n * user credentials. Next, it creates a new todo item associated with the\n * created user's ID via POST\n * /todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems.\n * Finally, it updates the user's details via PUT\n * /todoListApp/user/todoListAppUsers/{id}. The test verifies that the user\n * creation, todo item creation, and user update API calls succeed with valid\n * data adhering to schema constraints, including required properties and\n * formats. It also validates the integrity of updated user data by asserting\n * updated properties. Error scenarios for unauthorized updates are not\n * explicitly modeled due to lack of explicit API definitions and instruction\n * brevity, but the test ensures safety by sequential authentication and data\n * ownership. All DTO types used are from the provided structures, with proper\n * `satisfies` usage and typia assertions to ensure type safety. All\n * asynchronous calls await completion, and descriptive TestValidator assertions\n * are included to validate the business logic and API contract requirements.\n */\nexport async function test_api_todo_list_app_user_update_with_todo_item_dependency(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user account via /auth/user/join\n  const userCreateBody = typia.random<ITodoListAppUser.ICreate>();\n\n  const userAuthorized: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: userCreateBody,\n    });\n  typia.assert(userAuthorized);\n\n  // 2. Create a new todo item owned by the created user\n  const todoCreateBody = {\n    description: RandomGenerator.paragraph({\n      sentences: 5,\n      wordMin: 4,\n      wordMax: 7,\n    }),\n    status: \"pending\",\n    todo_list_app_user_id: userAuthorized.id,\n  } satisfies ITodoListAppTodoItem.ICreate;\n\n  const todoItem: ITodoListAppTodoItem =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.create(\n      connection,\n      {\n        todoListAppUserId: userAuthorized.id,\n        body: todoCreateBody,\n      },\n    );\n  typia.assert(todoItem);\n\n  // 3. Update the user's details via PUT\n  const userUpdateBody = {\n    email: typia.random<string & tags.Format<\"email\">>(),\n    password_hash: RandomGenerator.alphaNumeric(20),\n    email_verified: true,\n    updated_at: new Date().toISOString(),\n    created_at: new Date().toISOString(),\n    deleted_at: null,\n  } satisfies ITodoListAppTodoListAppUsers.IUpdate;\n\n  const updatedUser: ITodoListAppTodoListAppUsers =\n    await api.functional.todoListApp.user.todoListAppUsers.update(connection, {\n      id: userAuthorized.id,\n      body: userUpdateBody,\n    });\n  typia.assert(updatedUser);\n\n  // Validate that updated user fields match update request\n  TestValidator.equals(\n    \"user email updated correctly\",\n    updatedUser.email,\n    userUpdateBody.email,\n  );\n  TestValidator.equals(\n    \"user password_hash updated correctly\",\n    updatedUser.password_hash,\n    userUpdateBody.password_hash,\n  );\n  TestValidator.equals(\n    \"user email_verified updated correctly\",\n    updatedUser.email_verified,\n    userUpdateBody.email_verified,\n  );\n  // created_at and updated_at might differ slightly in backend but check for presence\n  TestValidator.predicate(\n    \"user created_at is valid ISO date\",\n    typeof updatedUser.created_at === \"string\" &&\n      updatedUser.created_at.length > 0,\n  );\n  TestValidator.predicate(\n    \"user updated_at is valid ISO date\",\n    typeof updatedUser.updated_at === \"string\" &&\n      updatedUser.updated_at.length > 0,\n  );\n  TestValidator.equals(\"user deleted_at is null\", updatedUser.deleted_at, null);\n}\n"},{"scenario":{"endpoint":{"path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems","method":"patch"},"draft":"This scenario tests the retrieval of a paginated and filtered list of todo items owned by an authenticated user. It starts by creating a new user with the 'join' endpoint to establish a new user context. Then, it creates a todo item for this user to ensure there is existing task data for retrieval. The test performs a PATCH request to fetch the todo items list with appropriate filtering and pagination parameters. It validates that the response returns the correct tasks belonging only to the authenticated user, ensuring proper authorization enforcement. Additionally, it verifies data integrity by checking the correctness of task details, pagination metadata, and that no tasks from other users are included.","functionName":"test_api_todo_items_list_retrieval_by_user","dependencies":[{"endpoint":{"method":"post","path":"/auth/user/join"},"purpose":"Authenticate as user for performing todo item retrieval"},{"endpoint":{"method":"post","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems"},"purpose":"Create a todo item owned by the user for retrieval testing"}]},"location":"test/features/api/todo_list_app_todo_items/test_api_todo_items_list_retrieval_by_user.ts","content":"import { ArrayUtil, RandomGenerator, TestValidator } from \"@nestia/e2e\";\nimport { IConnection } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\n\nimport api from \"@ORGANIZATION/PROJECT-api\";\nimport type { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport type { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport type { IPageITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAppTodoItem\";\nimport type { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport type { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\n\nexport async function test_api_todo_items_list_retrieval_by_user(\n  connection: api.IConnection,\n) {\n  // 1. Register a new user to obtain the auth token and user ID\n  const userCreateBody = {\n    email: RandomGenerator.alphaNumeric(8) + \"@example.com\",\n    password_hash: RandomGenerator.alphaNumeric(16),\n    email_verified: true,\n  } satisfies ITodoListAppUser.ICreate;\n  const authorizedUser: ITodoListAppUser.IAuthorized =\n    await api.functional.auth.user.join(connection, {\n      body: userCreateBody,\n    });\n  typia.assert(authorizedUser);\n\n  // 2. Create a todo item for this user to have data to retrieve\n  const todoCreateBody = {\n    description: RandomGenerator.paragraph({\n      sentences: 5,\n      wordMin: 4,\n      wordMax: 8,\n    }),\n    status: \"pending\",\n    todo_list_app_user_id: authorizedUser.id,\n  } satisfies ITodoListAppTodoItem.ICreate;\n  const todoItem: ITodoListAppTodoItem =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.create(\n      connection,\n      {\n        todoListAppUserId: authorizedUser.id,\n        body: todoCreateBody,\n      },\n    );\n  typia.assert(todoItem);\n\n  // 3. Prepare request body for indexing todo items with pagination and optional search\n  const patchRequestBody = {\n    page: 1,\n    limit: 10,\n    search: todoCreateBody.description.substring(0, 6), // partial search term\n  } satisfies ITodoListAppTodoItem.IRequest;\n\n  // 4. Retrieve todo items list for this user\n  const todoListResponse: IPageITodoListAppTodoItem.ISummary =\n    await api.functional.todoListApp.user.todoListAppUsers.todoListAppTodoItems.index(\n      connection,\n      {\n        todoListAppUserId: authorizedUser.id,\n        body: patchRequestBody,\n      },\n    );\n  typia.assert(todoListResponse);\n\n  // 5. Validate pagination metadata\n  const pagination = todoListResponse.pagination;\n  TestValidator.predicate(\n    \"page number should be at least 1\",\n    pagination.current >= 1,\n  );\n  TestValidator.predicate(\"limit should be positive\", pagination.limit > 0);\n  TestValidator.predicate(\n    \"total records should be at least 1\",\n    pagination.records >= 1,\n  );\n  TestValidator.predicate(\"pages should be at least 1\", pagination.pages >= 1);\n\n  // 6. Validate that every returned todo item matches search term and has valid properties\n  for (const task of todoListResponse.data) {\n    TestValidator.predicate(\n      \"todo item description includes search term\",\n      task.description.includes(patchRequestBody.search!),\n    );\n    TestValidator.predicate(\n      \"todo item status is valid\",\n      task.status === \"pending\" || task.status === \"done\",\n    );\n    TestValidator.predicate(\n      \"todo item created_at is ISO date\",\n      !isNaN(Date.parse(task.created_at)),\n    );\n  }\n\n  // 7. Confirm the created todo item is in the retrieved list\n  const found = todoListResponse.data.find((t) => t.id === todoItem.id);\n  TestValidator.predicate(\n    \"created todo item should exist in result\",\n    found !== undefined,\n  );\n  if (found !== undefined) {\n    TestValidator.equals(\n      \"created todo item description matches\",\n      found.description,\n      todoCreateBody.description,\n    );\n    TestValidator.equals(\n      \"created todo item status matches\",\n      found.status,\n      todoCreateBody.status,\n    );\n  }\n}\n"}],"compiled":{"type":"success"},"created_at":"2025-09-30T15:28:56.509Z","completed_at":"2025-09-30T15:36:37.708Z","step":0},{"id":"01999b44-c347-76e8-ae2a-b2509a3e9b98","type":"userMessage","contents":[{"type":"text","text":"Implement API functions."}],"created_at":"2025-09-30T15:36:38.983Z"},{"type":"realize","id":"01999b48-d804-7276-90b8-387a242f96ab","instruction":"Implement the business logic for the Todo list application API functions based on the confirmed requirements and generated API interfaces. The implementation should handle adding new tasks, marking tasks as done, deleting tasks, and retrieving the list of tasks. It must enforce data validation and maintain integrity using Prisma as the ORM. The service should be simple and efficient, focusing on correctness and minimal complexity to meet the basic Todo list functionality.","authorizations":[{"error_analysis":"The compilation error is a missing module './MyConfiguration' import in src/MyGlobal.ts, unrelated to authorization provider or decorator code. No errors found in provider, decorator, or payload code regarding TypeScript types or imports. Provider and decorator components correctly use jwtAuthorize import from './jwtAuthorize' and Prisma model names match schema. Payload definition consistent with typia tag usage and UUID formatting. Naming conventions are correct.","solution_guidance":"Fix the import error by adding or correcting './MyConfiguration' module in src/MyGlobal.ts; this is outside the authorization code scope. No changes are needed in provider, decorator, and payload codes. The provided provider uses correct async/await, exception handling, and Prisma usage. Decorator correctly uses Singleton and SwaggerCustomizer, with proper typings and import paths. Maintain current naming conventions as they fit specification.","provider":{"name":"userAuthorize","content":"import { ForbiddenException } from \"@nestjs/common\";\n\nimport { MyGlobal } from \"../../MyGlobal\";\nimport { jwtAuthorize } from \"./jwtAuthorize\";\nimport { UserPayload } from \"../../decorators/payload/UserPayload\";\n\nexport async function userAuthorize(request: { headers: { authorization?: string } }): Promise<UserPayload> {\n  const payload: UserPayload = jwtAuthorize({ request }) as UserPayload;\n\n  if (payload.type !== \"user\") {\n    throw new ForbiddenException(`You're not ${payload.type}`);\n  }\n\n  const user = await MyGlobal.prisma.todo_list_app_users.findFirst({\n    where: {\n      id: payload.id,\n      deleted_at: null\n    }\n  });\n\n  if (user === null) {\n    throw new ForbiddenException(\"You're not enrolled\");\n  }\n\n  return payload;\n}\n","location":"src/providers/authorize/userAuthorize.ts"},"decorator":{"name":"UserAuth","content":"import { SwaggerCustomizer } from \"@nestia/core\";\nimport { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\nimport { Singleton } from \"tstl\";\n\nimport { userAuthorize } from \"../providers/authorize/userAuthorize\";\n\nexport const UserAuth =\n  (): ParameterDecorator =>\n  (target: object, propertyKey: string | symbol | undefined, parameterIndex: number): void => {\n    SwaggerCustomizer((props) => {\n      props.route.security ??= [];\n      props.route.security.push({ bearer: [] });\n    })(target, propertyKey as string, undefined!);\n    singleton.get()(target, propertyKey, parameterIndex);\n  };\n\nconst singleton = new Singleton(() =>\n  createParamDecorator(async (_0: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return userAuthorize(request);\n  })(),\n);\n","location":"src/decorators/UserAuth.ts"},"payload":{"name":"UserPayload","location":"src/decorators/payload/UserPayload.ts","content":"import { tags } from \"typia\";\n\nexport interface UserPayload {\n  /** Top-level user table ID (the fundamental user identifier in the system). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Discriminator for the discriminated union type. */\n  type: \"user\";\n}\n"},"role":{"name":"user","description":"Authenticated users who can create, read, update, and delete their own todo items. They have personal access to their tasks and can manage them fully.","kind":"member"}}],"functions":[{"location":"src/providers/patchTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport { IPageITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAppTodoItem\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function patchTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems(props: {\n  user: UserPayload;\n  todoListAppUserId: string & tags.Format<\"uuid\">;\n  body: ITodoListAppTodoItem.IRequest;\n}): Promise<IPageITodoListAppTodoItem.ISummary> {\n  const { user, todoListAppUserId, body } = props;\n\n  if (user.id !== todoListAppUserId) {\n    throw new HttpException(\n      \"Forbidden: Cannot access other users' todo items\",\n      403,\n    );\n  }\n\n  const page = Number(body.page ?? 1);\n  const limit = Number(body.limit ?? 10);\n  const skip = (page - 1) * limit;\n\n  const where = {\n    todo_list_app_user_id: todoListAppUserId,\n    ...(body.search !== undefined &&\n      body.search !== null &&\n      body.search.length > 0 && {\n        description: { contains: body.search },\n      }),\n  };\n\n  const [items, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_app_todo_items.findMany({\n      where,\n      orderBy: { created_at: \"desc\" },\n      skip,\n      take: limit,\n      select: {\n        id: true,\n        description: true,\n        status: true,\n        created_at: true,\n      },\n    }),\n    MyGlobal.prisma.todo_list_app_todo_items.count({ where }),\n  ]);\n\n  const data = items.map((item) => ({\n    id: item.id,\n    description: item.description,\n    status: typia.assert<\"pending\" | \"done\">(item.status),\n    created_at: toISOStringSafe(item.created_at),\n  }));\n\n  const pagination = {\n    current: page,\n    limit: limit,\n    records: total,\n    pages: Math.ceil(total / limit),\n  };\n\n  return {\n    pagination,\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems"},"name":"patchTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems"},{"location":"src/providers/postTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\nexport async function postTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems(props: {\n  user: UserPayload;\n  todoListAppUserId: string & tags.Format<\"uuid\">;\n  body: ITodoListAppTodoItem.ICreate;\n}): Promise<ITodoListAppTodoItem> {\n  const { user, todoListAppUserId, body } = props;\n\n  if (user.id !== todoListAppUserId) {\n    throw new HttpException(\n      \"Unauthorized: You can only create todo items for your own user ID\",\n      403,\n    );\n  }\n\n  const description = body.description;\n  if (description.length === 0 || description.length > 256) {\n    throw new HttpException(\n      \"Bad Request: Description must be non-empty and at most 256 characters\",\n      400,\n    );\n  }\n\n  const status = body.status;\n  if (status !== \"pending\" && status !== \"done\") {\n    throw new HttpException(\n      \"Bad Request: Status must be either 'pending' or 'done'\",\n      400,\n    );\n  }\n\n  const now = toISOStringSafe(new Date());\n\n  const created = await MyGlobal.prisma.todo_list_app_todo_items.create({\n    data: {\n      id: v4() as string & tags.Format<\"uuid\">,\n      todo_list_app_user_id: todoListAppUserId,\n      description,\n      status,\n      created_at: now,\n      updated_at: now,\n    },\n  });\n\n  return {\n    id: created.id,\n    todo_list_app_user_id: created.todo_list_app_user_id,\n    description: created.description,\n    status: created.status as \"pending\" | \"done\",\n    created_at: toISOStringSafe(created.created_at),\n    updated_at: toISOStringSafe(created.updated_at),\n  };\n}\n","endpoint":{"method":"post","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems"},"name":"postTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems"},{"location":"src/providers/postAuthUserJoin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Registers a new user account for the 'user' role in the todoListApp backend.\n *\n * This endpoint allows public user registration by creating a new user record\n * with hashed password and unverified email status. Upon successful creation,\n * it generates JWT access and refresh tokens for immediate authenticated\n * usage.\n *\n * @param props - Object containing the user registration data.\n * @param props.body - User creation data including email and plain password.\n * @returns The authorized user data containing user ID and JWT tokens.\n * @throws {HttpException} When user creation fails (e.g., duplicate email).\n */\nexport async function postAuthUserJoin(props: {\n  body: ITodoListAppUser.ICreate;\n}): Promise<ITodoListAppUser.IAuthorized> {\n  const { body } = props;\n\n  // Hash the password\n  const hashedPassword = await PasswordUtil.hash(body.password_hash);\n\n  // Prepare timestamps as ISO strings\n  const now = toISOStringSafe(new Date());\n\n  // Generate new user ID as UUID v4\n  const newUserId = v4() as string & tags.Format<\"uuid\">;\n\n  // Create new user in database\n  const newUser = await MyGlobal.prisma.todo_list_app_users.create({\n    data: {\n      id: newUserId,\n      email: body.email,\n      password_hash: hashedPassword,\n      email_verified: false,\n      created_at: now,\n      updated_at: now,\n    },\n    select: {\n      id: true,\n      email: true,\n    },\n  });\n\n  // Prepare JWT tokens\n  const accessToken = jwt.sign(\n    {\n      userId: newUser.id,\n      email: newUser.email,\n    },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"1h\",\n      issuer: \"autobe\",\n    },\n  );\n\n  const refreshToken = jwt.sign(\n    {\n      userId: newUser.id,\n      tokenType: \"refresh\",\n    },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n\n  // Calculate expiration ISO strings\n  const expiredAt = toISOStringSafe(new Date(Date.now() + 3600 * 1000)); // 1 hour later\n  const refreshableUntil = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 3600 * 1000),\n  ); // 7 days later\n\n  // Return authorized user data\n  return {\n    id: newUser.id,\n    token: {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: expiredAt,\n      refreshable_until: refreshableUntil,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/join"},"name":"postAuthUserJoin"},{"location":"src/providers/postAuthUserLogin.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * User login for the todo_list_app_users table.\n *\n * Authenticates a user by verifying email and password. Validates that the\n * email is verified and user is not soft deleted. Returns JWT access and\n * refresh tokens upon successful login.\n *\n * @param props - Object containing user login credentials.\n * @param props.body - Login credentials including email and password.\n * @param props.user - The authenticated user payload (not used for login).\n * @returns Authorized user data with JWT tokens.\n * @throws {HttpException} 401 if credentials are invalid or user not found.\n */\nexport async function postAuthUserLogin(props: {\n  user: UserPayload;\n  body: ITodoListAppUser.ILogin;\n}): Promise<ITodoListAppUser.IAuthorized> {\n  const { body } = props;\n\n  const user = await MyGlobal.prisma.todo_list_app_users.findFirst({\n    where: {\n      email: body.email,\n      email_verified: true,\n      deleted_at: null,\n    },\n  });\n\n  if (!user) {\n    throw new HttpException(\"Invalid credentials\", 401);\n  }\n\n  const passwordValid = await PasswordUtil.verify(\n    body.password,\n    user.password_hash,\n  );\n  if (!passwordValid) {\n    throw new HttpException(\"Invalid credentials\", 401);\n  }\n\n  const now = toISOStringSafe(new Date());\n\n  const accessToken = jwt.sign(\n    {\n      userId: user.id,\n      email: user.email,\n    },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"1h\",\n      issuer: \"autobe\",\n    },\n  );\n\n  const refreshToken = jwt.sign(\n    {\n      userId: user.id,\n      tokenType: \"refresh\",\n    },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: \"7d\",\n      issuer: \"autobe\",\n    },\n  );\n\n  const expiredAt = toISOStringSafe(new Date(Date.now() + 3600 * 1000));\n  const refreshableUntil = toISOStringSafe(\n    new Date(Date.now() + 7 * 24 * 3600 * 1000),\n  );\n\n  return {\n    id: user.id,\n    token: {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: expiredAt,\n      refreshable_until: refreshableUntil,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/login"},"name":"postAuthUserLogin"},{"location":"src/providers/postAuthUserRefresh.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppUser } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppUser\";\nimport { IAuthorizationToken } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAuthorizationToken\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Refresh JWT token for todoListApp user using a valid refresh token.\n *\n * Validates the provided refresh token, verifies user existence with confirmed\n * email and no deletion, and issues new JWT access and refresh tokens.\n *\n * @param props - Object containing the authenticated user and the body with\n *   refresh token.\n * @param props.user - The authenticated user payload (not used for\n *   authorization here).\n * @param props.body - The request body containing the refresh token.\n * @returns The authorized user information with new tokens.\n * @throws HttpException(401) When the refresh token is invalid, expired, or\n *   user not found.\n */\nexport async function postAuthUserRefresh(props: {\n  user: UserPayload;\n  body: ITodoListAppUser.IRefresh;\n}): Promise<ITodoListAppUser.IAuthorized> {\n  const { body } = props;\n\n  let decoded: any;\n  try {\n    decoded = jwt.verify(body.refreshToken, MyGlobal.env.JWT_SECRET_KEY, {\n      issuer: \"autobe\",\n    });\n  } catch {\n    throw new HttpException(\n      \"Unauthorized: Invalid or expired refresh token\",\n      401,\n    );\n  }\n\n  if (\n    typeof decoded !== \"object\" ||\n    decoded === null ||\n    typeof decoded.id !== \"string\"\n  ) {\n    throw new HttpException(\"Unauthorized: Invalid token payload\", 401);\n  }\n\n  const user = await MyGlobal.prisma.todo_list_app_users.findFirst({\n    where: {\n      id: decoded.id,\n      email_verified: true,\n      deleted_at: null,\n    },\n  });\n\n  if (!user) {\n    throw new HttpException(\"Unauthorized: User not found or inactive\", 401);\n  }\n\n  // Define expiration times for tokens\n  const now = new Date();\n  const accessTokenExpiresIn = 60 * 60; // 1 hour in seconds\n  const refreshTokenExpiresIn = 7 * 24 * 60 * 60; // 7 days in seconds\n\n  const accessTokenExp = new Date(now.getTime() + accessTokenExpiresIn * 1000);\n  const refreshTokenExp = new Date(\n    now.getTime() + refreshTokenExpiresIn * 1000,\n  );\n\n  // Convert to ISO strings with tags, no Date usage in properties\n  const accessExpiredAt = accessTokenExp.toISOString() as string &\n    tags.Format<\"date-time\">;\n  const refreshExpiredAt = refreshTokenExp.toISOString() as string &\n    tags.Format<\"date-time\">;\n\n  // Create JWT tokens\n  const accessToken = jwt.sign(\n    { id: user.id, type: \"user\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: accessTokenExpiresIn,\n      issuer: \"autobe\",\n    },\n  );\n\n  const refreshToken = jwt.sign(\n    { id: user.id, tokenType: \"refresh\" },\n    MyGlobal.env.JWT_SECRET_KEY,\n    {\n      expiresIn: refreshTokenExpiresIn,\n      issuer: \"autobe\",\n    },\n  );\n\n  return {\n    id: user.id,\n    token: {\n      access: accessToken,\n      refresh: refreshToken,\n      expired_at: accessExpiredAt,\n      refreshable_until: refreshExpiredAt,\n    },\n  };\n}\n","endpoint":{"method":"post","path":"/auth/user/refresh"},"name":"postAuthUserRefresh"},{"location":"src/providers/getTodoListAppUserTodoListAppUsersId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppTodoListAppUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoListAppUsers\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Retrieve detailed information of a specific todo list app user account.\n *\n * This operation fetches detailed public user data (excluding sensitive\n * password hash) for the authenticated user. Only a user may retrieve their own\n * information. Attempting to access another user's data will result in a 403\n * Forbidden error.\n *\n * @param props - Object containing the authenticated user payload and the\n *   target user ID\n * @param props.user - The authenticated user requesting the data\n * @param props.id - The UUID of the user to retrieve\n * @returns The detailed user account information excluding password hash\n * @throws {HttpException} 403 if the user tries to access other user's\n *   information\n * @throws {HttpException} 404 if the user does not exist\n */\nexport async function getTodoListAppUserTodoListAppUsersId(props: {\n  user: UserPayload;\n  id: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListAppTodoListAppUsers.ISafe> {\n  const { user, id } = props;\n\n  if (user.id !== id) {\n    throw new HttpException(\"Forbidden: cannot access other user's data\", 403);\n  }\n\n  const record = await MyGlobal.prisma.todo_list_app_users.findUniqueOrThrow({\n    where: { id },\n    select: {\n      id: true,\n      email: true,\n      email_verified: true,\n      created_at: true,\n      updated_at: true,\n      deleted_at: true,\n    },\n  });\n\n  return {\n    id: record.id,\n    email: record.email,\n    email_verified: record.email_verified,\n    created_at: toISOStringSafe(record.created_at),\n    updated_at: toISOStringSafe(record.updated_at),\n    deleted_at: record.deleted_at ? toISOStringSafe(record.deleted_at) : null,\n  };\n}\n","endpoint":{"method":"get","path":"/todoListApp/user/todoListAppUsers/{id}"},"name":"getTodoListAppUserTodoListAppUsersId"},{"location":"src/providers/patchTodoListAppUserTodoListAppUsers.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppTodoListAppUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoListAppUsers\";\nimport { IPageITodoListAppTodoListAppUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageITodoListAppTodoListAppUsers\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPage\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Search and retrieve a filtered, paginated list of todo list app users.\n *\n * This endpoint supports optional filtering by email substring and email\n * verification status. Supports pagination with page and limit parameters, and\n * sorting by email or created_at. Soft-deleted users (deleted_at not null) are\n * excluded.\n *\n * @param props - The request properties containing the authenticated user and\n *   search filters.\n * @param props.user - The authenticated user making the request.\n * @param props.body - The filter and pagination criteria.\n * @returns A paginated summary list of todo list app users matching the search\n *   criteria.\n * @throws {HttpException} Throws if unexpected database errors occur.\n */\nexport async function patchTodoListAppUserTodoListAppUsers(props: {\n  user: UserPayload;\n  body: ITodoListAppTodoListAppUsers.IRequest;\n}): Promise<IPageITodoListAppTodoListAppUsers.ISummary> {\n  const { body } = props;\n\n  // Normalize pagination parameters with sensible defaults\n  const page = (body.page ?? 1) as number &\n    tags.Type<\"int32\"> &\n    tags.Minimum<0> as number;\n  const limit = (body.limit ?? 10) as number &\n    tags.Type<\"int32\"> &\n    tags.Minimum<0> as number;\n  const skip = (page - 1) * limit;\n\n  // Build the filtering conditions\n  const where: Prisma.todo_list_app_usersWhereInput = {\n    deleted_at: null,\n    ...(body.search !== undefined &&\n      body.search !== null && {\n        email: { contains: body.search },\n      }),\n    ...(body.email_verified !== undefined &&\n      body.email_verified !== null && {\n        email_verified: body.email_verified,\n      }),\n  };\n\n  // Determine sort field and order\n  const validSortFields = new Set([\"email\", \"created_at\"]);\n  const sortField =\n    body.sort_by && validSortFields.has(body.sort_by)\n      ? body.sort_by\n      : \"created_at\";\n  const sortOrder = body.order === \"asc\" ? \"asc\" : \"desc\";\n\n  // Query the filtered, paginated list and total count concurrently\n  const [results, total] = await Promise.all([\n    MyGlobal.prisma.todo_list_app_users.findMany({\n      where,\n      select: {\n        id: true,\n        email: true,\n        email_verified: true,\n        created_at: true,\n      },\n      orderBy: { [sortField]: sortOrder },\n      skip,\n      take: limit,\n    }),\n    MyGlobal.prisma.todo_list_app_users.count({ where }),\n  ]);\n\n  // Map results to response format, converting dates properly\n  const data = results.map((user) => ({\n    id: user.id as string & tags.Format<\"uuid\">,\n    email: user.email,\n    email_verified: user.email_verified,\n    created_at: toISOStringSafe(user.created_at),\n  }));\n\n  // Construct pagination metadata\n  const paginated = {\n    current: Number(page),\n    limit: Number(limit),\n    records: total,\n    pages: Math.ceil(total / limit),\n  };\n\n  return {\n    pagination: paginated,\n    data,\n  };\n}\n","endpoint":{"method":"patch","path":"/todoListApp/user/todoListAppUsers"},"name":"patchTodoListAppUserTodoListAppUsers"},{"location":"src/providers/putTodoListAppUserTodoListAppUsersId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppTodoListAppUsers } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoListAppUsers\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Update details of a specific todo list app user account.\n *\n * This operation updates user-owned fields ensuring email uniqueness and proper\n * authorization.\n *\n * @param props - Object containing user auth, target id, and update data.\n * @param props.user - Authenticated user payload for ownership verification.\n * @param props.id - UUID of the user to update.\n * @param props.body - Fields to update in the user account.\n * @returns The updated user record with applied changes.\n * @throws {HttpException} 403 if unauthorized access.\n * @throws {HttpException} 404 if user not found.\n * @throws {HttpException} 409 if email already in use by another user.\n */\nexport async function putTodoListAppUserTodoListAppUsersId(props: {\n  user: UserPayload;\n  id: string & tags.Format<\"uuid\">;\n  body: ITodoListAppTodoListAppUsers.IUpdate;\n}): Promise<ITodoListAppTodoListAppUsers> {\n  const { user, id, body } = props;\n\n  // 1. Fetch the user to update and verify existence and soft deletion\n  const existingUser = await MyGlobal.prisma.todo_list_app_users.findUnique({\n    where: { id },\n  });\n\n  if (!existingUser || existingUser.deleted_at !== null) {\n    throw new HttpException(\"User not found\", 404);\n  }\n\n  // 2. Authorization: Only the owner user can update their own account\n  if (user.id !== id) {\n    throw new HttpException(\n      \"Unauthorized: Cannot update another user's account\",\n      403,\n    );\n  }\n\n  // 3. Check unique email conflict if email is being updated\n  if (body.email !== undefined && body.email !== existingUser.email) {\n    const emailConflict = await MyGlobal.prisma.todo_list_app_users.findFirst({\n      where: {\n        email: body.email,\n        deleted_at: null,\n        // Exclude current user from conflict check\n        NOT: { id },\n      },\n      select: { id: true },\n    });\n    if (emailConflict) {\n      throw new HttpException(\"Email already in use\", 409);\n    }\n  }\n\n  // 4. Prepare update data inline for Prisma\n  const updatedUser = await MyGlobal.prisma.todo_list_app_users.update({\n    where: { id },\n    data: {\n      email: body.email ?? undefined,\n      password_hash: body.password_hash ?? undefined,\n      email_verified: body.email_verified ?? undefined,\n      created_at: body.created_at\n        ? toISOStringSafe(body.created_at)\n        : undefined,\n      updated_at: body.updated_at\n        ? toISOStringSafe(body.updated_at)\n        : undefined,\n      deleted_at:\n        body.deleted_at === null ? null : (body.deleted_at ?? undefined),\n    },\n  });\n\n  // 5. Return updated record with proper date conversions\n  return {\n    id: updatedUser.id as string & tags.Format<\"uuid\">,\n    email: updatedUser.email,\n    password_hash: updatedUser.password_hash,\n    email_verified: updatedUser.email_verified,\n    created_at: toISOStringSafe(updatedUser.created_at),\n    updated_at: toISOStringSafe(updatedUser.updated_at),\n    deleted_at: updatedUser.deleted_at\n      ? toISOStringSafe(updatedUser.deleted_at)\n      : null,\n  };\n}\n","endpoint":{"method":"put","path":"/todoListApp/user/todoListAppUsers/{id}"},"name":"putTodoListAppUserTodoListAppUsersId"},{"location":"src/providers/deleteTodoListAppUserTodoListAppUsersId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Permanently deletes the user account specified by the given UUID id.\n *\n * This operation verifies that the requester is the owner of the account before\n * proceeding. If the user does not exist, a 404 error is thrown. If the\n * requester is not the owner, a 403 error is thrown.\n *\n * @param props - Parameters\n * @param props.user - The authenticated user requesting the deletion\n * @param props.id - The UUID of the user account to delete\n * @throws {HttpException} 404 if the user does not exist\n * @throws {HttpException} 403 if unauthorized user attempts deletion\n */\nexport async function deleteTodoListAppUserTodoListAppUsersId(props: {\n  user: UserPayload;\n  id: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const userRecord = await MyGlobal.prisma.todo_list_app_users.findUnique({\n    where: { id: props.id },\n  });\n\n  if (!userRecord) {\n    throw new HttpException(\"User not found\", 404);\n  }\n\n  if (userRecord.id !== props.user.id) {\n    throw new HttpException(\n      \"Unauthorized: You can only delete your own account\",\n      403,\n    );\n  }\n\n  await MyGlobal.prisma.todo_list_app_users.delete({\n    where: { id: props.id },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoListApp/user/todoListAppUsers/{id}"},"name":"deleteTodoListAppUserTodoListAppUsersId"},{"location":"src/providers/getTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Get details of a specific todo item owned by a user.\n *\n * Retrieves the todo item specified by its UUID and the owning user's UUID.\n * Ensures the authenticated user is authorized to access the item.\n *\n * @param props - Parameters including authenticated user, todoListAppUserId,\n *   and todo item id\n * @param props.user - Authenticated user payload\n * @param props.todoListAppUserId - UUID of the user who owns the todo item\n * @param props.id - UUID of the todo item\n * @returns Detailed todo item data including description, status, created_at\n *   and updated_at\n * @throws HttpException 403 if the authenticated user is not the owner\n * @throws HttpException 404 if the todo item does not exist\n */\nexport async function getTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId(props: {\n  user: UserPayload;\n  todoListAppUserId: string & tags.Format<\"uuid\">;\n  id: string & tags.Format<\"uuid\">;\n}): Promise<ITodoListAppTodoItem> {\n  const { user, todoListAppUserId, id } = props;\n\n  if (user.id !== todoListAppUserId) {\n    throw new HttpException(\n      \"Forbidden: You can only access your own todo items\",\n      403,\n    );\n  }\n\n  const todoItem =\n    await MyGlobal.prisma.todo_list_app_todo_items.findUniqueOrThrow({\n      where: { id },\n    });\n\n  if (todoItem.todo_list_app_user_id !== todoListAppUserId) {\n    throw new HttpException(\n      \"Forbidden: You can only access your own todo items\",\n      403,\n    );\n  }\n\n  return {\n    id: todoItem.id,\n    todo_list_app_user_id: todoItem.todo_list_app_user_id,\n    description: todoItem.description,\n    status: todoItem.status === \"pending\" ? \"pending\" : \"done\",\n    created_at: toISOStringSafe(todoItem.created_at),\n    updated_at: toISOStringSafe(todoItem.updated_at),\n  };\n}\n","endpoint":{"method":"get","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}"},"name":"getTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId"},{"location":"src/providers/putTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { ITodoListAppTodoItem } from \"@ORGANIZATION/PROJECT-api/lib/structures/ITodoListAppTodoItem\";\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Updates an existing todo item owned by the specified user.\n *\n * Enforces that only the authenticated user owning the todo item can perform\n * the update. Description updates are allowed only if the current status is\n * 'pending'. Status must be either 'pending' or 'done'.\n *\n * Throws 403 if the authenticated user does not own the todo item. Throws 400\n * if trying to update description when status is not 'pending', or invalid\n * status value. Throws 404 if the todo item does not exist.\n *\n * @param props - Object containing user payload, user ID, todo item ID, and\n *   update body\n * @returns Updated todo item entity\n * @throws {HttpException} 403 if unauthorized access\n * @throws {HttpException} 400 for validation errors\n * @throws {HttpException} 404 if item not found\n */\nexport async function putTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId(props: {\n  user: UserPayload;\n  todoListAppUserId: string & tags.Format<\"uuid\">;\n  id: string & tags.Format<\"uuid\">;\n  body: ITodoListAppTodoItem.IUpdate;\n}): Promise<ITodoListAppTodoItem> {\n  const { user, todoListAppUserId, id, body } = props;\n\n  // Authorization check\n  if (user.id !== todoListAppUserId) {\n    throw new HttpException(\n      \"Unauthorized: You can only update your own todo items\",\n      403,\n    );\n  }\n\n  // Find the existing todo item and verify ownership\n  const existing =\n    await MyGlobal.prisma.todo_list_app_todo_items.findFirstOrThrow({\n      where: {\n        id,\n        todo_list_app_user_id: todoListAppUserId,\n      },\n    });\n\n  // Validate status if present\n  if (\n    body.status !== undefined &&\n    body.status !== \"pending\" &&\n    body.status !== \"done\"\n  ) {\n    throw new HttpException(\"Invalid status value\", 400);\n  }\n\n  // Enforce description update only if current status is 'pending'\n  if (body.description !== undefined && existing.status !== \"pending\") {\n    throw new HttpException(\n      \"Description can only be updated if current status is 'pending'\",\n      400,\n    );\n  }\n\n  // Prepare update data with updated_at\n  const now = toISOStringSafe(new Date());\n\n  const updated = await MyGlobal.prisma.todo_list_app_todo_items.update({\n    where: { id },\n    data: {\n      description: body.description ?? undefined,\n      status: body.status ?? undefined,\n      updated_at: now,\n    },\n  });\n\n  // Return updated todo item with date conversions\n  return {\n    id: updated.id,\n    todo_list_app_user_id: updated.todo_list_app_user_id,\n    description: updated.description,\n    status: updated.status === \"pending\" ? \"pending\" : \"done\",\n    created_at: toISOStringSafe(updated.created_at),\n    updated_at: toISOStringSafe(updated.updated_at),\n  };\n}\n","endpoint":{"method":"put","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}"},"name":"putTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId"},{"location":"src/providers/deleteTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId.ts","content":"import { HttpException } from \"@nestjs/common\";\nimport { Prisma } from \"@prisma/client\";\nimport jwt from \"jsonwebtoken\";\nimport typia, { tags } from \"typia\";\nimport { v4 } from \"uuid\";\nimport { MyGlobal } from \"../MyGlobal\";\nimport { PasswordUtil } from \"../utils/passwordUtil\";\nimport { toISOStringSafe } from \"../utils/toISOStringSafe\";\n\nimport { UserPayload } from \"../decorators/payload/UserPayload\";\n\n/**\n * Delete a todo item permanently.\n *\n * Removes a todo item owned by the specified user from the database. This\n * operation performs a hard delete since the todo item table does not support\n * soft delete. Ownership is verified to enforce authorization.\n *\n * @param props - The function parameters containing user authentication and\n *   identifiers\n * @param props.user - Authenticated user making the request\n * @param props.todoListAppUserId - ID of the user who owns the todo item\n * @param props.id - ID of the todo item to delete\n * @throws {HttpException} Throws 403 if the authenticated user is not the owner\n * @throws {HttpException} Throws 404 if the todo item does not exist\n */\nexport async function deleteTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId(props: {\n  user: UserPayload;\n  todoListAppUserId: string & tags.Format<\"uuid\">;\n  id: string & tags.Format<\"uuid\">;\n}): Promise<void> {\n  const { user, todoListAppUserId, id } = props;\n\n  const todoItem =\n    await MyGlobal.prisma.todo_list_app_todo_items.findUniqueOrThrow({\n      where: { id },\n      select: { todo_list_app_user_id: true },\n    });\n\n  if (todoItem.todo_list_app_user_id !== user.id) {\n    throw new HttpException(\n      \"Unauthorized: not the owner of this todo item\",\n      403,\n    );\n  }\n\n  await MyGlobal.prisma.todo_list_app_todo_items.delete({\n    where: { id },\n  });\n}\n","endpoint":{"method":"delete","path":"/todoListApp/user/todoListAppUsers/{todoListAppUserId}/todoListAppTodoItems/{id}"},"name":"deleteTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId"}],"controllers":{"src/controllers/auth/user/AuthUserController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody } from \"@nestia/core\";\nimport typia from \"typia\";\nimport { postAuthUserJoin } from \"../../../providers/postAuthUserJoin\";\nimport { UserAuth } from \"../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../decorators/payload/UserPayload\";\nimport { postAuthUserLogin } from \"../../../providers/postAuthUserLogin\";\nimport { postAuthUserRefresh } from \"../../../providers/postAuthUserRefresh\";\n\nimport { ITodoListAppUser } from \"../../../api/structures/ITodoListAppUser\";\n\n@Controller(\"/auth/user\")\nexport class AuthUserController {\n  /**\n   * Register new user for todo_list_app_users table.\n   *\n   * Registers a new user account for the 'user' role in the todoListApp\n   * backend. Validates email and password, stores user with hashed password and\n   * unverified email status. On success, issues JWT access and refresh tokens.\n   * This operation targets the todo_list_app_users table representing user\n   * accounts. It manages creation timestamps and enforces email uniqueness.\n   * This endpoint uses the 'join' authorization type indicating user\n   * registration. Validation of email format and password policies are enforced\n   * at the application layer before calling. Returns an authorized user\n   * response type ITodoListAppUser.IAuthorized.\n   *\n   * @param connection\n   * @param body User registration data including email and password,\n   *   encapsulated in ITodoListAppUser.ICreate.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"join\")\n  public async join(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoListAppUser.ICreate,\n  ): Promise<ITodoListAppUser.IAuthorized> {\n    try {\n      return await postAuthUserJoin({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * User login for todo_list_app_users table.\n   *\n   * Authenticates an existing user by verifying email and password for the\n   * 'user' role in todoListApp. Validates credentials against stored password\n   * hash and email verification status. Issues JWT access and refresh tokens\n   * upon successful login. Relies on todo_list_app_users table with unique\n   * email and password_hash fields. Ensures user is not soft deleted and has\n   * verified email. Uses 'login' authorization type as a secure authentication\n   * entry point. Returns authorized user response\n   * ITodoListAppUser.IAuthorized.\n   *\n   * @param connection\n   * @param body Login credentials including email and password, defined in\n   *   ITodoListAppUser.ILogin.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"login\")\n  public async login(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoListAppUser.ILogin,\n  ): Promise<ITodoListAppUser.IAuthorized> {\n    try {\n      return await postAuthUserLogin({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Refresh JWT token for todo_list_app_users table.\n   *\n   * Refreshes JWT access token for the 'user' role using a valid refresh token.\n   * Ensures continuous authenticated session without user re-login. Relies on\n   * the todo_list_app_users table to validate user existence, email\n   * verification status, and account state. Uses 'refresh' authorization type\n   * indicating token renewal. Returns authorized user response\n   * ITodoListAppUser.IAuthorized with new tokens.\n   *\n   * @param connection\n   * @param body Refresh token request data containing the refresh token,\n   *   defined in ITodoListAppUser.IRefresh.\n   * @setHeader token.access Authorization\n   *\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post(\"refresh\")\n  public async refresh(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoListAppUser.IRefresh,\n  ): Promise<ITodoListAppUser.IAuthorized> {\n    try {\n      return await postAuthUserRefresh({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoListApp/user/todoListAppUsers/TodolistappUserTodolistappusersController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { getTodoListAppUserTodoListAppUsersId } from \"../../../../providers/getTodoListAppUserTodoListAppUsersId\";\nimport { UserAuth } from \"../../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../../decorators/payload/UserPayload\";\nimport { putTodoListAppUserTodoListAppUsersId } from \"../../../../providers/putTodoListAppUserTodoListAppUsersId\";\nimport { deleteTodoListAppUserTodoListAppUsersId } from \"../../../../providers/deleteTodoListAppUserTodoListAppUsersId\";\nimport { patchTodoListAppUserTodoListAppUsers } from \"../../../../providers/patchTodoListAppUserTodoListAppUsers\";\n\nimport { ITodoListAppTodoListAppUsers } from \"../../../../api/structures/ITodoListAppTodoListAppUsers\";\nimport { IPageITodoListAppTodoListAppUsers } from \"../../../../api/structures/IPageITodoListAppTodoListAppUsers\";\n\n@Controller(\"/todoListApp/user/todoListAppUsers\")\nexport class TodolistappUserTodolistappusersController {\n  /**\n   * Retrieve detailed information of a specific todo list app user account.\n   *\n   * This operation fetches detailed information about a single user account\n   * identified by their unique UUID. It retrieves the user's email, email\n   * verification status, and timestamps related to when the account was\n   * created, last updated, and deleted (if soft deleted).\n   *\n   * Security considerations require that only authorized roles can access this\n   * endpoint since it exposes sensitive authentication data. The password hash\n   * field is excluded to prevent exposure of sensitive information.\n   *\n   * The operation tightly couples with the todo_list_app_users table in the\n   * Prisma schema ensuring that the exact fields and data integrity rules are\n   * respected. It returns a complete user object matching the schema\n   * properties, excluding sensitive password data.\n   *\n   * Typical errors include attempting to fetch a user ID that does not exist,\n   * which should return a not-found error. Unauthorized access attempts should\n   * be rejected with a 403 or similar error.\n   *\n   * This operation is distinct from list or update operations and serves as a\n   * granular user data retrieval endpoint, often supporting administrative or\n   * account management UI features.\n   *\n   * @param connection\n   * @param id Unique identifier of the todo list app user\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":id\")\n  public async at(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListAppTodoListAppUsers.ISafe> {\n    try {\n      return await getTodoListAppUserTodoListAppUsersId({\n        user,\n        id,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update details of a specific todo list app user account.\n   *\n   * Update detailed information of an existing todo list app user account. The\n   * request body must contain the updated email, password hash, email\n   * verification status, and timestamps as needed. The user account is\n   * identified by the id path parameter. Ownership and permission checks ensure\n   * only authorized modification.\n   *\n   * This operation modifies core user identity fields and is critical for\n   * account management and security enforcement.\n   *\n   * Proper validation and transactional integrity are essential to maintain\n   * data consistency and application security.\n   *\n   * @param connection\n   * @param id Unique identifier of the todo list app user to update\n   * @param body Updated user account information for the specified user ID\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":id\")\n  public async update(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListAppTodoListAppUsers.IUpdate,\n  ): Promise<ITodoListAppTodoListAppUsers> {\n    try {\n      return await putTodoListAppUserTodoListAppUsersId({\n        user,\n        id,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a todoListApp user account by id.\n   *\n   * Permanently removes the user account record specified by the {id} in the\n   * path from the database, including cascade deletion of owned todo items as\n   * per Prisma schema rules. This operation MUST verify that the requesting\n   * user is authorized to delete their own account to prevent unauthorized user\n   * removal. It operates directly on the todo_list_app_users table, which\n   * stores user authentication credentials and related metadata.\n   *\n   * Security considerations require strong authentication and authorization\n   * checks, as deleting a user account cannot be undone and will remove all\n   * associated task data. This endpoint is critical and must ensure only the\n   * authenticated owner can perform this deletion.\n   *\n   * Expected behavior includes validation of the {id} as a UUID, verification\n   * of user ownership, and a hard (permanent) delete operation with no\n   * recovery.\n   *\n   * No request body is sent, and no response body is returned on successful\n   * deletion. Error handling includes responding with authorization errors for\n   * unauthorized attempts, not found errors if the user does not exist, and\n   * appropriate server error messages for unexpected failures.\n   *\n   * @param connection\n   * @param id Unique identifier of the user account to delete\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":id\")\n  public async erase(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoListAppUserTodoListAppUsersId({\n        user,\n        id,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Search and retrieve a filtered, paginated list of todo list app users.\n   *\n   * This operation enables clients to perform complex search and retrieval\n   * operations over todo list app users. The request body supports specifying\n   * search filters like email substring matching, filtering by email\n   * verification status, and sorting preferences including sort column and\n   * order.\n   *\n   * The response is a paginated list of user summary objects optimized for UI\n   * rendering in admin or management dashboards.\n   *\n   * Proper validation of input parameters in the request body ensures effective\n   * filtering and prevents injection or invalid queries.\n   *\n   * Security constraints mean only authorized user roles can execute this\n   * operation, limiting exposure of sensitive user data.\n   *\n   * This endpoint complements single-entity retrieval and update endpoints\n   * providing complete user account management capabilities.\n   *\n   * @param connection\n   * @param body Search criteria and pagination parameters for todo list user\n   *   filtering\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @UserAuth()\n    user: UserPayload,\n    @TypedBody()\n    body: ITodoListAppTodoListAppUsers.IRequest,\n  ): Promise<IPageITodoListAppTodoListAppUsers.ISummary> {\n    try {\n      return await patchTodoListAppUserTodoListAppUsers({\n        user,\n        body,\n      });\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n","src/controllers/todoListApp/user/todoListAppUsers/todoListAppTodoItems/TodolistappUserTodolistappusersTodolistapptodoitemsController.ts":"import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\nimport { postTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems } from \"../../../../../providers/postTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems\";\nimport { UserAuth } from \"../../../../../decorators/UserAuth\";\nimport { UserPayload } from \"../../../../../decorators/payload/UserPayload\";\nimport { patchTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems } from \"../../../../../providers/patchTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems\";\nimport { getTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId } from \"../../../../../providers/getTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId\";\nimport { putTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId } from \"../../../../../providers/putTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId\";\nimport { deleteTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId } from \"../../../../../providers/deleteTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId\";\n\nimport { ITodoListAppTodoItem } from \"../../../../../api/structures/ITodoListAppTodoItem\";\nimport { IPageITodoListAppTodoItem } from \"../../../../../api/structures/IPageITodoListAppTodoItem\";\n\n@Controller(\n  \"/todoListApp/user/todoListAppUsers/:todoListAppUserId/todoListAppTodoItems\",\n)\nexport class TodolistappUserTodolistappusersTodolistapptodoitemsController {\n  /**\n   * Create a new todo item for a user.\n   *\n   * Creates a new todo item owned by the specified user. The description must\n   * be non-empty and at most 256 characters. Status must be either 'pending' or\n   * 'done', typically 'pending' at creation. The item is uniquely identified\n   * and timestamps for creation and last update are recorded.\n   *\n   * Only the authenticated user owning the specified user ID may perform this\n   * operation. The system enforces ownership and validates input values.\n   *\n   * The operation relates to the todo_list_app_todo_items table in the Prisma\n   * schema. It references todo_list_app_users via the foreign key\n   * todo_list_app_user_id. The response entity contains all standard todo item\n   * fields.\n   *\n   * Errors may occur if the description is invalid, if the status is not\n   * recognized, or if authorization fails.\n   *\n   * Client must supply the user ID in the path and a valid request body\n   * matching the ITodoListAppTodoItem.ICreate schema.\n   *\n   * Related operations include retrieving the todo items list, updating\n   * existing items, and deleting items.\n   *\n   * @param connection\n   * @param todoListAppUserId Unique identifier of the owning todo list app user\n   * @param body Creation info of the todo item\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Post()\n  public async create(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoListAppUserId\")\n    todoListAppUserId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListAppTodoItem.ICreate,\n  ): Promise<ITodoListAppTodoItem> {\n    try {\n      return await postTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems(\n        {\n          user,\n          todoListAppUserId,\n          body,\n        },\n      );\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve a filtered and paginated list of todo items for a user.\n   *\n   * Retrieve a filtered and paginated list of todo items owned by the user\n   * identified by {todoListAppUserId}. This supports searching, sorting, and\n   * paging to optimize task management.\n   *\n   * This operation enforces ownership, meaning users can only retrieve their\n   * own tasks. It interacts with the todo_list_app_todo_items table, which\n   * stores task descriptions, statuses (only \"pending\" or \"done\"), and\n   * timestamps.\n   *\n   * Security measures ensure the requesting user is authenticated and\n   * authorized to view only their own tasks. Validation of the\n   * {todoListAppUserId} as a UUID is performed. The response includes task\n   * summary details with pagination data.\n   *\n   * Typical usage includes client applications requesting the current user's\n   * task list with filter criteria, page size, and sort order.\n   *\n   * Errors include authorization failures if attempting to access other users'\n   * tasks and proper handling of invalid request parameters or server errors.\n   *\n   * @param connection\n   * @param todoListAppUserId Identifier of the user owning the todo items\n   * @param body Search criteria and pagination parameters for todo items\n   *   filtering\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Patch()\n  public async index(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoListAppUserId\")\n    todoListAppUserId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListAppTodoItem.IRequest,\n  ): Promise<IPageITodoListAppTodoItem.ISummary> {\n    try {\n      return await patchTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItems(\n        {\n          user,\n          todoListAppUserId,\n          body,\n        },\n      );\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get details of a specific todo item owned by a user.\n   *\n   * Retrieve detailed information about a specific todo item owned by the user\n   * identified by {todoListAppUserId} and the todo item identified by {id}.\n   *\n   * Only the owning user is authorized to access this data. The todo item\n   * includes fields for description, status (\"pending\" or \"done\"), creation,\n   * and update timestamps.\n   *\n   * This operation requires validation of both path parameters as UUIDs and\n   * enforces strict ownership checking.\n   *\n   * Common errors are authorization failure if the item belongs to another\n   * user, and not found if the item does not exist.\n   *\n   * The response provides full task details for client applications requiring\n   * display or editing functionality.\n   *\n   * @param connection\n   * @param todoListAppUserId Unique identifier of the user owning the todo item\n   * @param id Unique identifier of the todo item\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Get(\":id\")\n  public async at(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoListAppUserId\")\n    todoListAppUserId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<ITodoListAppTodoItem> {\n    try {\n      return await getTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId(\n        {\n          user,\n          todoListAppUserId,\n          id,\n        },\n      );\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update an existing todo item.\n   *\n   * Updates an existing todo item owned by the specified user. Description\n   * changes are allowed only if the item is currently 'pending'. Status can be\n   * updated to 'done' or 'pending'.\n   *\n   * The operation verifies user ownership and validates the description length\n   * and status value.\n   *\n   * This operation manipulates the todo_list_app_todo_items DB table and\n   * relates to todo_list_app_users for ownership.\n   *\n   * Request must include user ID and todo item ID in path and request body with\n   * updated fields matching ITodoListAppTodoItem.IUpdate.\n   *\n   * Errors returned include authorization failure, validation errors, or item\n   * not found errors.\n   *\n   * This complements the create and delete operations for managing todo items.\n   *\n   * @param connection\n   * @param todoListAppUserId Unique identifier of the owning todo list app user\n   * @param id Unique identifier of the todo item\n   * @param body Updated data for the todo item\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Put(\":id\")\n  public async update(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoListAppUserId\")\n    todoListAppUserId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ITodoListAppTodoItem.IUpdate,\n  ): Promise<ITodoListAppTodoItem> {\n    try {\n      return await putTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId(\n        {\n          user,\n          todoListAppUserId,\n          id,\n          body,\n        },\n      );\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a todo item permanently.\n   *\n   * Deletes a todo item owned by the specified user. This operation permanently\n   * removes the record from the database.\n   *\n   * It verifies ownership and returns no response content.\n   *\n   * The todo_list_app_todo_items schema does not support soft delete, so this\n   * is a hard delete.\n   *\n   * Errors include authorization failure or item not found.\n   *\n   * Client must provide user ID and todo item ID in the path.\n   *\n   * Related operations include creating, updating, and retrieving todo items.\n   *\n   * @param connection\n   * @param todoListAppUserId Unique identifier of the owning todo list app user\n   * @param id Unique identifier of the todo item\n   * @nestia Generated by Nestia - https://github.com/samchon/nestia\n   */\n  @TypedRoute.Delete(\":id\")\n  public async erase(\n    @UserAuth()\n    user: UserPayload,\n    @TypedParam(\"todoListAppUserId\")\n    todoListAppUserId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    try {\n      return await deleteTodoListAppUserTodoListAppUsersTodoListAppUserIdTodoListAppTodoItemsId(\n        {\n          user,\n          todoListAppUserId,\n          id,\n        },\n      );\n    } catch (error) {\n      console.log(error);\n      throw error;\n    }\n  }\n}\n"},"compiled":{"type":"success"},"created_at":"2025-09-30T15:36:41.205Z","completed_at":"2025-09-30T15:41:06.436Z","step":0}]